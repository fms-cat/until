!function(e){var t={};function n(r){if(t[r])return t[r].exports;var a=t[r]={i:r,l:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.l=!0,a.exports}n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var a in e)n.d(r,a,function(t){return e[t]}.bind(null,a));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=64)}([function(e,t,n){"use strict";n.d(t,"c",function(){return r}),n.d(t,"d",function(){return a}),n.d(t,"e",function(){return i}),n.d(t,"f",function(){return o}),n.d(t,"a",function(){return l}),n.d(t,"b",function(){return s});const r=[-1,-1,1,-1,-1,1,1,1],a=[-1,-1,0,1,-1,0,-1,1,0,1,1,0],i=[0,0,1,0,0,1,0,0,1,0,0,1],o=[0,0,1,0,0,1,1,1],l=e=>{let t=[];for(let n=0;n<e;n++)t.push(n);return t},s=(e,t)=>{let n=[];for(let r=0;r<t;r++)for(let t=0;t<e;t++)n.push(t,r);return n}},function(e,t,n){"use strict";const r={vecAdd:(e,t)=>e.map((e,n)=>e+t[n]),vecSub:(e,t)=>e.map((e,n)=>e-t[n]),vecMul:(e,t)=>e.map((e,n)=>e-t[n]),vec3Cross:(e,t)=>[e[1]*t[2]-e[2]*t[1],e[2]*t[0]-e[0]*t[2],e[0]*t[1]-e[1]*t[0]],vecScale:(e,t)=>t.map(t=>t*e),vecDot:(e,t)=>e.reduce((e,n,r)=>e+n*t[r],0),vecLength:e=>Math.sqrt(e.reduce((e,t)=>e+t*t,0)),vecNormalize:e=>r.vecScale(1/r.vecLength(e),e),quatMul:(e,t)=>[e[3]*t[0]+e[0]*t[3]+e[1]*t[2]-e[2]*t[1],e[3]*t[1]-e[0]*t[2]+e[1]*t[3]+e[2]*t[0],e[3]*t[2]+e[0]*t[1]-e[1]*t[0]+e[2]*t[3],e[3]*t[3]-e[0]*t[0]-e[1]*t[1]-e[2]*t[2]],quatInv:e=>[-e[0],-e[1],-e[2],e[3]],rotateVecByQuat:(e,t)=>{const n=[e[0],e[1],e[2],0],a=r.quatInv(t),i=r.quatMul(r.quatMul(t,n),a);return[i[0],i[1],i[2]]},quatToMat4:e=>{const t=r.rotateVecByQuat([1,0,0],e),n=r.rotateVecByQuat([0,1,0],e),a=r.rotateVecByQuat([0,0,1],e);return[t[0],n[0],a[0],0,t[1],n[1],a[1],0,t[2],n[2],a[2],0,0,0,0,1]},quatAngleAxis:(e,t)=>{const n=e/2,r=Math.sin(n);return[t[0]*r,t[1]*r,t[2]*r,Math.cos(n)]},mat4Apply:(...e)=>{const t=e[0],n=e[1];if(3<e.length){const a=e.slice(2);return r.mat4Apply(r.mat4Apply(t,n),...a)}return[t[0]*n[0]+t[4]*n[1]+t[8]*n[2]+t[12]*n[3],t[1]*n[0]+t[5]*n[1]+t[9]*n[2]+t[13]*n[3],t[2]*n[0]+t[6]*n[1]+t[10]*n[2]+t[14]*n[3],t[3]*n[0]+t[7]*n[1]+t[11]*n[2]+t[15]*n[3],t[0]*n[4]+t[4]*n[5]+t[8]*n[6]+t[12]*n[7],t[1]*n[4]+t[5]*n[5]+t[9]*n[6]+t[13]*n[7],t[2]*n[4]+t[6]*n[5]+t[10]*n[6]+t[14]*n[7],t[3]*n[4]+t[7]*n[5]+t[11]*n[6]+t[15]*n[7],t[0]*n[8]+t[4]*n[9]+t[8]*n[10]+t[12]*n[11],t[1]*n[8]+t[5]*n[9]+t[9]*n[10]+t[13]*n[11],t[2]*n[8]+t[6]*n[9]+t[10]*n[10]+t[14]*n[11],t[3]*n[8]+t[7]*n[9]+t[11]*n[10]+t[15]*n[11],t[0]*n[12]+t[4]*n[13]+t[8]*n[14]+t[12]*n[15],t[1]*n[12]+t[5]*n[13]+t[9]*n[14]+t[13]*n[15],t[2]*n[12]+t[6]*n[13]+t[10]*n[14]+t[14]*n[15],t[3]*n[12]+t[7]*n[13]+t[11]*n[14]+t[15]*n[15]]},mat4Inverse:e=>{const t=e[0],n=e[1],a=e[2],i=e[3],o=e[4],l=e[5],s=e[6],u=e[7],f=e[8],m=e[9],c=e[10],v=e[11],p=e[12],d=e[13],h=e[14],x=e[15],g=t*l-n*o,b=t*s-a*o,_=t*u-i*o,T=n*s-a*l,E=n*u-i*l,y=a*u-i*s,w=f*d-m*p,R=f*h-c*p,A=f*x-v*p,P=m*h-c*d,F=m*x-v*d,I=c*x-v*h;return r.vecScale(1/g*I-b*F+_*P+T*A-E*R+y*w,[l*I-s*F+u*P,a*F-n*I-i*P,d*y-h*E+x*T,c*E-m*y-v*T,s*A-o*I-u*R,t*I-a*A+i*R,h*_-p*y-x*b,f*y-c*_+v*b,o*F-l*A+u*w,n*A-t*F-i*w,p*E-d*_+x*g,m*_-f*E-v*g,l*R-o*P-s*w,t*P-n*R+a*w,d*b-p*T-h*g,f*T-m*b+c*g])},mat4ApplyToVec4:(e,t)=>[e[0]*t[0]+e[4]*t[1]+e[8]*t[2]+e[12]*t[3],e[1]*t[0]+e[5]*t[1]+e[9]*t[2]+e[13]*t[3],e[2]*t[0]+e[6]*t[1]+e[10]*t[2]+e[14]*t[3],e[3]*t[0]+e[7]*t[1]+e[11]*t[2]+e[15]*t[3]],mat4Transpose:e=>[e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15]],mat4Identity:()=>[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],mat4Translate:e=>[1,0,0,0,0,1,0,0,0,0,1,0,e[0],e[1],e[2],1],mat4Scale:e=>[e[0],0,0,0,0,e[1],0,0,0,0,e[2],0,0,0,0,1],mat4ScaleXYZ:e=>[e,0,0,0,0,e,0,0,0,0,e,0,0,0,0,1],mat4RotateX:e=>[1,0,0,0,0,Math.cos(e),-Math.sin(e),0,0,Math.sin(e),Math.cos(e),0,0,0,0,1],mat4RotateY:e=>[Math.cos(e),0,Math.sin(e),0,0,1,0,0,-Math.sin(e),0,Math.cos(e),0,0,0,0,1],mat4RotateZ:e=>[Math.cos(e),-Math.sin(e),0,0,Math.sin(e),Math.cos(e),0,0,0,0,1,0,0,0,0,1],mat4LookAt:(e,t,n,a)=>{const i=r.vecNormalize(r.vecSub(t,e));let o=r.vecNormalize(r.vec3Cross(i,n||[0,1,0])),l=r.vec3Cross(o,i);return o=r.vecAdd(r.vecScale(Math.cos(a||0),o),r.vecScale(Math.sin(a||0),l)),l=r.vec3Cross(o,i),[o[0],l[0],i[0],0,o[1],l[1],i[1],0,o[2],l[2],i[2],0,-o[0]*e[0]-o[1]*e[1]-o[2]*e[2],-l[0]*e[0]-l[1]*e[1]-l[2]*e[2],-i[0]*e[0]-i[1]*e[1]-i[2]*e[2],1]},mat4Perspective:(e,t,n)=>{const r=1/Math.tan(e*Math.PI/360),a=n-t;return[r,0,0,0,0,r,0,0,0,0,(n+t)/a,1,0,0,-2*n*t/a,0]}};t.a=r},function(e,t){e.exports="attribute vec2 p;\n\nvoid main() {\n  gl_Position = vec4( p, 0.0, 1.0 );\n}"},function(e,t,n){"use strict";n.d(t,"a",function(){return r});const r=class{constructor(e){this.set(e)}gen(e){return e&&this.set(e),this.seed=this.seed^this.seed<<13,this.seed=this.seed^this.seed>>>17,this.seed=this.seed^this.seed<<5,this.seed/Math.pow(2,32)+.5}genFloat32Array(e){const t=new Float32Array(e);for(let n=0;n<e;n++)t[n]=this.gen();return t}set(e){this.seed=e||this.seed||1}}},function(e){e.exports={resolution:[1920,1080],shadowReso:512}},function(e,t){e.exports="#extension GL_EXT_draw_buffers : require\nprecision highp float;\n\n// ------\n\nvoid main() {\n  gl_FragData[ 0 ] = vec4( bgColor, 1.0 );\n  gl_FragData[ 1 ] = vec4( perspFar, 0.0, 0.0, 1.0 );\n}"},function(e,t,n){var r;e.exports=function e(t,n,a){function i(l,s){if(!n[l]){if(!t[l]){var u="function"==typeof r&&r;if(!s&&u)return r(l,!0);if(o)return o(l,!0);var f=new Error("Cannot find module '"+l+"'");throw f.code="MODULE_NOT_FOUND",f}var m=n[l]={exports:{}};t[l][0].call(m.exports,function(e){var n=t[l][1][e];return i(n||e)},m,m.exports,e,t,n,a)}return n[l].exports}for(var o="function"==typeof r&&r,l=0;l<a.length;l++)i(a[l]);return i}({1:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a=e("./clock"),i=function(e){return e&&e.__esModule?e:{default:e}}(a),o=function(e){function t(e,n){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t);var r=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return r.frame=0,r.fps=n,r}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(t,i.default),r(t,[{key:"update",value:function(){this.isPlaying?(this.time=this.frame/this.fps,this.deltaTime=1/this.fps,this.frame++):this.deltaTime=0}},{key:"setTime",value:function(e){this.frame=Math.floor(this.fps*e),this.time=this.frame/this.fps}}]),t}();n.default=o},{"./clock":3}],2:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a=e("./clock"),i=function(e){return e&&e.__esModule?e:{default:e}}(a),o=function(e){function t(e){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,t);var n=function(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,(t.__proto__||Object.getPrototypeOf(t)).call(this,e));return n.realtime=!0,n.rtTime=0,n.rtDate=+new Date,n}return function(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(t,i.default),r(t,[{key:"update",value:function(){if(this.isPlaying){var e=this.time,t=Date.now()-this.rtDate;this.time=this.rtTime+t/1e3,this.deltaTime=this.time-e}else this.rtTime=this.time,this.rtDate=+new Date,this.deltaTime=0}},{key:"setTime",value:function(e){this.time=e,this.rtTime=this.time,this.rtDate=+new Date}}]),t}();n.default=o},{"./clock":3}],3:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a=function(){function e(t){(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")})(this,e),this.automaton=t,this.time=0,this.deltaTime=0,this.isPlaying=!0}return r(e,[{key:"update",value:function(e){var t=this.time;this.time=e,this.deltaTime=this.time-t}},{key:"play",value:function(){this.isPlaying=!0}},{key:"pause",value:function(){this.isPlaying=!1}},{key:"setTime",value:function(e){this.time=e}}]),e}();n.default=a},{}],4:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=[],a=function(e,t){return 1-3*t+3*e},i=function(e,t){return 3*t-6*e},o=function(e){return 3*e},l=function(e){return Math.min(Math.max(e,0),1)},s=function(e,t,n){return((a(t,n)*e+i(t,n))*e+o(t))*e},u=function(e,t,n){return 3*a(t,n)*e*e+2*i(t,n)*e+o(t)},f=function(e,t,n,a,i){if(isNaN(e)||isNaN(t)||isNaN(n)||isNaN(a))return i;if(e===t&&n===a)return i;if(i<=0)return 0;if(1<=i)return 1;e=l(e),n=l(n);for(var o=0;o<21;o++)r[o]=s(o/20,e,n);for(var f=1,m=1;m<21&&(f=m-1,!(i<r[m]));m++);var c=(f+(i-r[f])/(r[f+1]-r[f]))/20,v=u(c,e,n);return.001<=v?c=function(e,t,n,r){for(var a=0;a<4;a++){var i=u(t,n,r);if(0===i)return t;t-=(s(t,n,r)-e)/i}return t}(i,c,e,n):0!==v&&(c=function(e,t,n,r,a){for(var i=0,o=0,l=0;l<10&&(0<(i=s(o=t+(n-t)/2,r,a)-e)?n=o:t=o,!(1e-6<Math.abs(i)));l++);return o}(i,f/20,(f+1)/20,e,n)),s(c,t,a)};n.default=function(e,t,n){var r=t.time-e.time,a=t.value-e.value,i=e.out.time/r,o=e.out.value/a,l=(t.time+t.in.time-e.time)/r,s=(t.value+t.in.value-e.value)/a,u=(n-e.time)/r;return e.value+f(i,o,l,s,u)*a}},{}],5:[function(e,t,n){"use strict";var r=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a=e("./clock"),i=c(a),o=e("./clock-frame"),l=c(o),s=e("./clock-realtime"),u=c(s),f=e("./param"),m=c(f);function c(e){return e&&e.__esModule?e:{default:e}}var v=function(){function e(t){var n=this;(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")})(this,e),this.__version="2.0.4",this.loop=t.loop||!1,this.__clock=t.fps?new l.default(this,t.fps):t.realtime?new u.default(this):new i.default(this),this.__listeners={},this.__paramFxDefs={};var r=t.data;this.load(r),this.auto=function(e){return n.__auto(e)}}return r(e,[{key:"createParam",value:function(e,t){this.__params[e]=new m.default({automaton:this,data:t})}},{key:"load",value:function(e){for(var t in this.__length=e.length,this.__resolution=e.resolution,this.__params={},e.params)this.createParam(t,e.params[t])}},{key:"seek",value:function(e){this.__clock.setTime(e),this.__emit("seek")}},{key:"play",value:function(){this.__clock.play(),this.__emit("play")}},{key:"pause",value:function(){this.__clock.pause(),this.__emit("pause")}},{key:"addFxDefinition",value:function(e,t){this.__paramFxDefs[e]=t,this.precalcAll()}},{key:"__emit",value:function(e){for(var t=arguments.length,n=Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];this.__listeners[e]&&this.__listeners[e].map(function(e){return e.apply(void 0,n)})}},{key:"on",value:function(e,t){this.__listeners[e]||(this.__listeners[e]=[]),this.__listeners[e].push(t)}},{key:"precalcAll",value:function(){for(var e in this.__params)this.__params[e].precalc()}},{key:"update",value:function(e){for(var t in this.__clock.update(e),this.loop&&(this.time<0||this.length<this.time)&&this.__clock.setTime(this.time-Math.floor(this.time/this.length)*this.length),this.__params)this.__params[t].getValue()}},{key:"__auto",value:function(e){return this.__params[e].getValue()}},{key:"version",get:function(){return this.__version}},{key:"time",get:function(){return this.__clock.time}},{key:"length",get:function(){return this.__length}},{key:"resolution",get:function(){return this.__resolution}},{key:"deltaTime",get:function(){return this.__clock.deltaTime}},{key:"isPlaying",get:function(){return this.__clock.isPlaying}},{key:"progress",get:function(){return this.time/this.length}},{key:"frame",get:function(){return this.__clock.frame?this.__clock.frame:void 0}},{key:"fps",get:function(){return this.__clock.fps?this.__clock.fps:void 0}},{key:"realtime",get:function(){return Boolean(this.__clock.realtime)}}]),e}();t.exports=v,v.default=v},{"./clock":3,"./clock-frame":1,"./clock-realtime":2,"./param":6}],6:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function e(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(t,n,r){return n&&e(t.prototype,n),r&&e(t,r),t}}(),a=e("./cubic-bezier"),i=l(a),o=e("./main");function l(e){return e&&e.__esModule?e:{default:e}}l(o);var s=function(){function e(t){(function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")})(this,e),this.__automaton=t.automaton,this.__values=new Float32Array(this.__automaton.resolution*this.__automaton.length+1),this.load(t.data),this.__lastValue=0,this.__lastTime=0}return r(e,[{key:"load",value:function(e){this.__nodes=e.nodes,this.__fxs=e.fxs,this.precalc()}},{key:"precalc",value:function(){for(var e=0;e<this.__nodes.length-1;e++){var t=this.__nodes[e],n=this.__nodes[e+1],r=Math.floor(t.time*this.__automaton.resolution),a=Math.floor(n.time*this.__automaton.resolution);this.__values[r]=t.value;for(var o=r+1;o<=a;o++){var l=o/this.__automaton.resolution,s=(0,i.default)(t,n,l);this.__values[o]=s}}for(var u=0;u<this.__fxs.length;u++){var f=this.__fxs[u];if(!f.bypass){var m=this.__automaton.__paramFxDefs[f.def];if(m){for(var c=Math.ceil(this.__automaton.resolution*f.time),v=Math.floor(this.__automaton.resolution*(f.time+f.length)),p=new Float32Array(v-c),d=p.length,h={i0:c,i1:v,t0:f.time,t1:f.time+f.length,deltaTime:1/this.__automaton.resolution,dt:1/this.__automaton.resolution,resolution:this.__automaton.resolution,length:f.length,params:f.params,array:this.__values,getValue:this.getValue.bind(this),init:!0},x=0;x<d;x++)h.i=h.index=x+c,h.t=h.time=h.i/this.__automaton.resolution,h.v=h.value=this.__values[x+c],h.p=h.progress=(h.t-f.time)/f.length,p[x]=m.func(h),h.init=!1;this.__values.set(p,c)}}}}},{key:"getValue",value:function(e){var t=e;if("number"!=typeof t&&(t=this.__automaton.time),t===this.__lastTime)return this.__lastValue;if(this.__automaton.loop&&(t-=Math.floor(t/this.__automaton.length)*this.__automaton.length),t<=0)return this.__values[0];if(this.__automaton.length<=t)return this.__values[this.__values.length-1];var n=t*this.__automaton.resolution,r=Math.floor(n),a=n%1,i=this.__values[r],o=i+(this.__values[r+1]-i)*a;return this.__lastTime=t,this.__lastValue=o,o}}]),e}();n.default=s},{"./cubic-bezier":4,"./main":5}]},{},[5])(5)},function(e,t){e.exports=(e=>{let t=[],n=[],r=[];const a=Object.assign({size:1},e).size;for(let e=0;e<6;e++){let i=[[-a,-a,a],[a,-a,a],[-a,a,a],[a,a,a]],o=[[0,0,1],[0,0,1],[0,0,1],[0,0,1]],l=[0,1,3,0,3,2].map(t=>t+4*e);if(0!==e){let t=t=>{if(e<4){let n=e*Math.PI/2,r=t[0],a=t[2];t[0]=Math.cos(n)*r-Math.sin(n)*a,t[2]=Math.sin(n)*r+Math.cos(n)*a}else{let n=(e-.5)*Math.PI,r=t[1],a=t[2];t[1]=Math.cos(n)*r-Math.sin(n)*a,t[2]=Math.sin(n)*r+Math.cos(n)*a}};i.map(t),o.map(t)}i.map(e=>t.push(...e)),o.map(e=>n.push(...e)),r.push(...l)}return{position:t,normal:n,index:r}})},function(e,t){e.exports="float aTime;\nfloat rawTime;\nfloat pattern;\n\nuniform float timeHead;\nuniform float patternHead;\nuniform float sampleRate;\nuniform float bufferSize;\nuniform sampler2D samplerChord;\n\nvec2 aNoise2( float t ) {\n  return 1.0 - 2.0 * texture2D( samplerRandomStatic, t * vec2( 0.741, 0.891 ) ).xy;\n}\n\nfloat i2f( float i ) {\n  float chord = (\n    rawTime < SECTION_WHAT_THE ?\n    0.0 :\n    mod( floor( rawTime / ( 8.0 beat ) ), 4.0 )\n  );\n\n  vec2 noteUv = ( vec2( mod( floor( i ), 8.0 ), chord ) + 0.5 ) / vec2( 8.0, 4.0 );\n  float note = texture2D( samplerChord, noteUv ).x;\n\n  float trans = -16.8 + (\n    rawTime < SECTION_WHAT_THE ?\n    0.0 :\n    mod( 5.0 - floor( rawTime / ( 8.0 beat ) ), 12.0 ) - 5.0\n  );\n\n  return n2f(\n    note + trans +\n    floor( i / 8.0 ) * 24.0 +\n    12.0 * linearstep( SECTION_AAAAA - 16.0 beat, SECTION_AAAAA, rawTime ) +\n    ( SECTION_AAAAA < rawTime ? -12.0 : 0.0 )\n  ); \n}\n\nvec2 kick( float t ) {\n  float attack = rawTime < SECTION_AAAAA ? 3.0 : 20.0;\n  float lorate = rawTime < SECTION_AAAAA ? 1E-9 : 0.04;\n\n  return vec2( exp( -10.0 * t ) * sin( TAU * lofi(\n    i2f( -8.0 ) * t - attack * ( exp( -40.0 * t ) + exp( -200.0 * t ) ),\n    lorate ) ) );\n}\n\nvec2 snare( float _phase ) {\n  if ( _phase < 0.0 ) { return vec2( 0.0 ); }\n  return aSaturate( (\n    aNoise2( _phase / 0.01 ).xy +\n    sin( _phase * 3600.0 * vec2( 1.005, 0.995 ) - exp( -_phase * 800.0 ) * 30.0 )\n  ) * 4.0 * exp( -_phase * 23.0 ) );\n}\n\nvec2 snare909( float _phase ) {\n  if ( _phase < 0.0 ) { return vec2( 0.0 ); }\n  return aSaturate( (\n    aNoise2( _phase / 0.01 ).xy * 2.0 +\n    sin( _phase * 1400.0 * vec2( 1.005, 0.995 ) - exp( -_phase * 80.0 ) * 30.0 )\n  ) * 1.0 * exp( -_phase * 10.0 ) );\n}\n\nvec2 tableTalking( float t, float offset ) {\n  vec4 dice = random4( offset );\n  return exp( -mix( 10.0, 30.0, dice.w ) * t ) * aSaturate( 5.0 * aNoise2(\n    100.0 * mod( t, mix( 0.008, 0.08, dice.x ) ) * mix( 0.01, 0.03, dice.y ) + 100.0 * dice.z\n  ) );\n}\n\nvec2 bass( float freq, float t ) {\n  vec2 hi = 16.0 + 0.1 * smoothstep( 0.0, 0.4, t ) * vec2( -1.0, 1.0 );\n  vec2 fm = 0.1 * smoothstep( 0.0, 0.4, t ) * sin(\n    TAU * freq * t + sin( TAU * hi * freq * t )\n  );\n  return vec2( tri( lofi( freq * t + fm, 0.0625 ) ) );\n}\n\nvec2 filterSaw( float freq, float time, float cutoff, float resonance ) {\n  if ( time < 0.0 ) { return vec2( 0.0 ); }\n  vec2 sum = vec2( 0.0 );\n  for ( int i = 1; i <= 32; i ++ ) {\n    float fi = float( i );\n    float cut = smoothstep( cutoff * 1.2, cutoff * 0.8, fi * freq );\n    cut += smoothstep( cutoff * 0.3, 0.0, abs( cutoff - fi * freq ) ) * resonance;\n    vec2 offset = vec2( -1.0, 1.0 ) * ( 0.1 * ( fi - 1.0 ) );\n    sum += sin( fi * freq * time * TAU + offset ) / fi * cut;\n  }\n  return sum;\n}\n\nvec2 rimshot( float _phase ) {\n  if ( _phase < 0.0 ) { return vec2( 0.0 ); }\n  float attack = exp( -_phase * 400.0 ) * 0.6;\n  vec2 wave = (\n    tri( _phase * 450.0 * vec2( 1.005, 0.995 ) - attack ) +\n    tri( _phase * 1800.0 * vec2( 0.995, 1.005 ) - attack )\n  );\n  return aSaturate( 4.0 * wave * exp( -_phase * 400.0 ) );\n}\n\nvec2 cowbell( float _phase ) {\n  if ( _phase < 0.0 ) { return vec2( 0.0 ); }\n  float attack = exp( -_phase * 800.0 ) * 20.0;\n  vec2 wave = (\n    pwm( _phase * 1600.0 * vec2( 1.005, 0.995 ) - attack, vec2( 0.5 ) ) +\n    pwm( _phase * 1080.0 * vec2( 0.995, 1.005 ) - attack, vec2( 0.5 ) )\n  ) * sin( _phase * 40.0 * TAU );\n  return wave * exp( -_phase * 20.0 );\n}\n\nvec2 chordSaw( float freq, float time ) {\n  vec2 p = fract( time * vec2( 0.99, 1.01 ) * freq );\n  return (\n    fract( 2.0 * p + 1.6 * sin( 2.0 * TAU * p ) ) - 0.5 +\n    fract( 1.0 * p ) - 0.5\n  );\n}\n\nvec2 wavetable( float freq, float time, float speed, float offset ) {\n  if ( time < 0.0 ) { return vec2( 0.0 ); }\n  float p = tri( freq * time );\n  return aNoise2( p * speed + offset );\n}\n\nvec2 clap( float _phase ) {\n  if ( _phase < 0.0 ) { return vec2( 0.0 ); }\n  float amp = exp( -14.0 * _phase );\n  amp *= mix(\n    smoothstep( 0.5, 0.4, sin( 500.0 * _phase ) ),\n    1.0,\n    smoothstep( 0.04, 0.05, _phase )\n  );\n  vec2 wave = wavetable( 1.2, _phase, 1.0, 0.0 );\n  return lofir( amp * wave, 0.25 );\n}\n\nvec2 crash( float _phase, float decay ) {\n  if ( _phase < 0.0 ) { return vec2( 0.0 ); }\n  float amp = exp( -decay * _phase );\n  vec2 wave = wavetable( 96.1, _phase, 0.5, 0.0 );\n  return amp * wave;\n}\n\nvec2 fmArp( float freq, float time ) {\n  if ( time < 0.0 ) { return vec2( 0.0 ); }\n  vec2 p = freq * vec2( 0.999, 1.001 ) * time * TAU;\n  float dl = exp( -time * 1.0 );\n  float ds = exp( -time * 10.0 );\n  return (\n    sin( p * 1.0003 + sin( p * 11.0035 ) * 1.5 * ds + sin( p * 1.0003 ) * 1.0 * dl ) +\n    sin( p * 0.9997 + sin( p * 0.9997 + sin( p * 4.9984 ) * 2.0 * dl ) * 0.5 * ds )\n  ) * 0.5 * ds;\n}\n\nvoid main() {\n  aTime = timeHead + ( floor( gl_FragCoord.x ) + bufferSize * floor( gl_FragCoord.y ) ) / sampleRate;\n  rawTime = aTime + 16.0 beat * patternHead;\n  pattern = patternHead + ( 16.0 beat < aTime ? 1.0 : 0.0 );\n  aTime = mod( aTime, 16.0 beat );\n\n  vec2 dest = vec2( 0.0 );\n\n  // -- tone -------------------------------------------------------------------\n  if ( rawTime < 16.0 beat ) {\n    if ( 8.0 beat < aTime ) {\n      float freq = mod( aTime, 4.0 beat ) < 1.0 beat ? 2000.0 : 1000.0;\n      float amp = smoothstep( 0.05, 0.04, mod( aTime, 1.0 beat ) );\n      dest.xy += amp * sin( freq * TAU * aTime );\n    }\n\n    gl_FragColor = vec4( dest, 0.0, 0.0 );\n    return;\n  }\n\n  // -- boom -------------------------------------------------------------------\n  if ( inRange( SECTION_AAAAA - 0.6 beat, SECTION_AAAAA, rawTime ) ) {\n    float t = ( aTime - 15.5 beat );\n    gl_FragColor = vec4( 0.4 * wavetable(\n      70.0, t, 0.2 * exp( -12.0 * t ), 0.0\n    ), 0.0, 0.0 );\n    return;\n  }\n\n  aTime = calcRhythms( aTime, rawTime );\n\n  // -- kick -------------------------------------------------------------------\n  dest += 0.5 * kick( kickTime );\n\n  // -- sweep ------------------------------------------------------------------\n  if ( inRange( SECTION_AAAAA - 16.0 beat, SECTION_AAAAA, rawTime ) ) {\n    float buildup = linearstep( SECTION_AAAAA - 16.0 beat, SECTION_AAAAA, rawTime );\n    dest += 0.1 * sqrt( buildup ) * wavetable( 40.0, aTime, 0.1 * buildup, 0.0 );\n  }\n\n  // -- crash ------------------------------------------------------------------\n  {\n    float amp = 0.2 * mix( 0.4, 1.0, sidechain );\n    dest += (\n      inRange( SECTION_HI_ACID, SECTION_HI_ACID + 16.0 beat, rawTime ) ||\n      inRange( SECTION_ITS_BEGINNING, SECTION_ITS_BEGINNING + 16.0 beat, rawTime ) ||\n      inRange( SECTION_AAAAA, SECTION_AAAAA + 16.0 beat, rawTime ) ||\n      inRange( SECTION_WHAT_THE, SECTION_WHAT_THE + 16.0 beat, rawTime ) ||\n      inRange( SECTION_FINISH, SECTION_FINISH + 16.0 beat, rawTime )\n    ) ? amp * crash( aTime, rawTime < SECTION_AAAAA ? 4.0 : 1.0 ) : vec2( 0.0 );\n  }\n\n  // -- clap -------------------------------------------------------------------\n  if ( inRange( SECTION_HI_ACID - 1.0 beat, SECTION_ITS_BEGINNING, rawTime ) ) {\n    dest += (\n      rawTime < SECTION_ITS_BEGINNING - 8.0 beat ?\n      0.2 * clap( mod( aTime - 1.0 beat, 2.0 beat ) ) :\n      vec2( 0.0 )\n    );\n  }\n\n  // -- acid -------------------------------------------------------------------\n  if ( inRange( SECTION_HI_ACID, SECTION_ITS_BEGINNING, rawTime ) ) {\n    if ( mod( aTime, 0.25 beat ) < 0.2 beat ) {\n      float t = mod( aTime, 0.25 beat );\n      vec4 dice = random4( lofi( rawTime + 4.12, 0.25 beat ) );\n      float filt = (\n        100.0 +\n        mix( 1000.0, 4000.0, dice.z ) * exp( -mix( 20.0, 40.0, dice.w ) * t )\n      );\n      float freq = (\n        i2f( -8.0 + 8.0 * pow( dice.y, 5.0 ) ) *\n        ( dice.x < 0.2 ? 1.335 : 1.0 ) *\n        ( dice.w < 0.5 ? 2.0 : 1.0 )\n      );\n      float amp = 0.16 * smoothstep( 0.25 beat, 0.2 beat, t );\n      dest += amp * aSaturate( 0.7 * filterSaw( freq, t, filt, filt / 500.0 ) );\n    }\n  }\n\n  // -- bass -------------------------------------------------------------------\n  if ( SECTION_AAAAA < rawTime ) {\n    dest += 0.4 * sidechain * bass( i2f( -8.0 ), kickTime );\n  }\n\n  // -- hihat ------------------------------------------------------------------\n  {\n    float amp = 0.3 * exp( -hihatOpen * hihatTime );\n    vec2 wave = wavetable( 80.0, hihatTime, 0.4, 0.0 );\n    dest += amp * wave;\n  }\n\n  // -- click ------------------------------------------------------------------\n  if ( rawTime < SECTION_ITS_BEGINNING - 1.0 beat ) {\n    float t = mod( aTime, 0.25 beat );\n    vec4 dice = random4( lofi( aTime, 0.25 beat ) );\n    t = mod( t, 0.25 / pow( 2.0, floor( 5.0 * pow( dice.z, 20.0 ) ) ) beat );\n    float amp = 0.3 * exp( -100.0 * t );\n    dest += amp * dice.xy;\n  }\n\n  // -- clav -------------------------------------------------------------------\n  if ( inRange( SECTION_HI_RIM, SECTION_ITS_BEGINNING, rawTime ) ) {\n    float amp = exp( -100.0 * clavTime );\n    float phase = clavTime + tri( 700.0 * clavTime );\n    dest += 0.2 * amp * tri( phase * vec2( 0.9, 1.1 ) );\n  }\n\n  // -- rimshot ----------------------------------------------------------------\n  if ( inRange( SECTION_HI_RIM, SECTION_ITS_BEGINNING - 4.0 beat, rawTime ) ) {\n    dest.x += 0.3 * rimshot( rimshotTime.x ).x;\n    dest.y += 0.3 * rimshot( rimshotTime.y ).y;\n  }\n\n  // -- snare ------------------------------------------------------------------\n  if (\n    inRange( SECTION_AAAAA, SECTION_FINISH, rawTime ) &&\n    !inRange( SECTION_WHAT_THE - 3.0 beat, SECTION_WHAT_THE, rawTime )\n  ) {\n    dest += 0.2 * snare( mod( aTime - 1.0 beat, 2.0 beat ) );\n  }\n\n  // -- snare909 ---------------------------------------------------------------\n  if ( inRange( SECTION_WHAT_THE - 8.0 beat, SECTION_WHAT_THE, rawTime ) ) {\n    float t = rawTime < SECTION_WHAT_THE - 2.0 beat ? mod( aTime, 0.25 beat ) : mod( aTime, 0.125 beat );\n    float amp = 0.14 * smoothstep( SECTION_WHAT_THE - 8.0 beat, SECTION_WHAT_THE, rawTime );\n    dest += amp * snare909( t );\n  }\n\n  // -- cowbell ----------------------------------------------------------------\n  if ( SECTION_AAAAA < rawTime ) {\n    dest += 0.1 * cowbell( mod( aTime - 0.25 beat, 2.0 beat ) );\n  }\n\n  // -- ???? -------------------------------------------------------------------\n  if ( SECTION_AAAAA < rawTime ) {\n    float t = mod( aTime, 32.0 beat );\n    float amp = 0.06 * sidechain;\n    vec2 wave = wavetable( 170.0, t, sidechain * 0.05, 0.0 );\n    dest += amp * wave;\n\n    dest += 0.08 * tableTalking( mod( aTime, 0.25 beat ), 4.8 * lofi( rawTime, 0.25 beat ) );\n  }\n\n  // -- pads -------------------------------------------------------------------\n  {\n    vec2 wave = vec2( 0.0 );\n    for ( int i = 0; i < 8; i ++ ) {\n      wave += (\n        rawTime < SECTION_ITS_BEGINNING + 16.0 beat ?\n        vec2( sin( TAU * lofi(\n          i2f( float( i ) ) * aTime + sin( float( i ) + 2.0 * aTime ),\n          0.0625\n        ) ) ) :\n        chordSaw( i2f( 2.3 * float( i - 2 ) ), aTime )\n      );\n    }\n    float env = 0.3 * linearstep( SECTION_ITS_BEGINNING + 16.0 beat, SECTION_AAAAA, rawTime );\n    float amp = 0.07 * sidechain * (\n      rawTime < SECTION_ITS_BEGINNING + 16.0 beat ?\n      0.8 * smoothstep( SECTION_ITS_BEGINNING + 16.0 beat, SECTION_ITS_BEGINNING, rawTime ) :\n      smoothstep( ( 0.1 + env ) beat, ( -0.2 + env ) beat, mod( aTime, 0.25 beat ) )\n    );\n    dest += amp * wave;\n  }\n\n  // -- arps -------------------------------------------------------------------\n  if ( SECTION_HI_ARP < rawTime ) {\n    for ( int i = 0; i < 3; i ++ ) {\n      float timeD = aTime - float( i ) * 0.75 beat;\n      float t = mod( timeD, 0.25 beat );\n      vec4 dice = random4( timeD - t + 2.59 );\n\n      float buildup = smoothstep( SECTION_ITS_BEGINNING, SECTION_AAAAA, rawTime );\n\n      float amp = (\n        rawTime < SECTION_WHAT_THE ?\n        0.12 * exp( -mix( 40.0, 10.0, buildup ) * t ) :\n        0.1\n      ) * exp( -mix( 4.0, 1.0, buildup ) * float( i ) );\n      float freq = (\n        rawTime < SECTION_WHAT_THE ?\n        i2f( 1.3 * floor( mod( timeD / ( 0.25 beat ), 8.0 ) ) ) :\n        i2f(\n          floor( 3.0 + 3.0 * tri( ( timeD - t ) / ( 1.0 beat ) ) + dice.x * 10.0 ) +\n          ( 0.8 < dice.y && 0.125 beat < t ? 2.0 : 0.0 )\n        )\n      );\n      float form = (\n        rawTime < SECTION_WHAT_THE ?\n        mix( 0.001, exp( -8.0 * t ) * 0.004, buildup ) :\n        -0.0015 * smoothstep( 0.4 beat, 0.0, t )\n      );\n\n      dest += amp * wavetable( freq, t, form, dice.w );\n    }\n  }\n\n  // -- chip -------------------------------------------------------------------\n  if ( SECTION_AAAAA < rawTime ) {\n    float freq = 2.0 * i2f( floor( mod( aTime * BPM / 3.75, 8.0 ) ) );\n    dest += vec2( 0.07 ) * sidechain * pwm( freq * aTime, 0.25 );\n  }\n\n  // fade out\n  dest *= smoothstep( 150.0, 142.0, rawTime );\n\n  gl_FragColor = vec4( dest, 0.0, 0.0 );\n}\n"},function(e,t){e.exports="// == defines ==================================================================\n#define PI 3.141592654\n#define TAU 6.283185307\n#define HUGE 9E16\n#define BPM 160.0\n#define saturate(i) clamp(i, 0.,1.)\n#define aSaturate(i) clamp(i, -1.,1.)\n#define linearstep(a,b,x) saturate(((x)-(a))/((b)-(a)))\n#define lofi(i,m) (floor((i)/(m))*(m))\n#define lofir(i,m) (floor((i)/(m)+0.5)*(m))\n#define pwm(x,d) (step(fract(x),(d))*2.0-1.0)\n#define tri(p) (1.-4.*abs(fract(p)-0.5))\n#define n2f(n) (440.0*pow(2.0,(n)/12.0))\n#define inRange(a,b,x) ((a)<=(x)&&(x)<(b))\n#define geta(i,m) (m)\n#define sinexp(i) (sin(PI*exp(i)))\n#define mp2zp(i) (.5+.5*(i))\n#define zp2mp(i) ((i)*2.-1.)\n#define beat *60.0/BPM\n\n// == sections =================================================================\n#define SECTION_HI_RIM (48.0 beat)\n#define SECTION_HI_ACID (80.0 beat)\n#define SECTION_HI_ARP (112.0 beat)\n#define SECTION_ITS_BEGINNING (144.0 beat)\n#define SECTION_AAAAA (240.0 beat)\n#define SECTION_WHAT_THE (304.0 beat)\n#define SECTION_FINISH (368.0 beat)\n\n// == h ========================================================================\nprecision highp float;\n\n// == globals ==================================================================\nfloat kickTime;\nfloat sidechain;\nvec2 rimshotTime;\nfloat clavTime;\nfloat hihatTime;\nfloat hihatOpen;\n\n// == uniforms =================================================================\nuniform bool isInitialFrame;\nuniform float time;\nuniform vec2 resolution;\nuniform float progress;\nuniform float deltaTime;\nuniform float totalFrame;\nuniform vec3 cameraPos;\nuniform vec3 cameraTar;\nuniform float cameraRoll;\nuniform float perspFov;\nuniform float perspNear;\nuniform float perspFar;\nuniform vec3 lightPos;\nuniform vec3 lightCol;\nuniform mat4 matP;\nuniform mat4 matV;\nuniform mat4 matPL;\nuniform mat4 matVL;\nuniform sampler2D samplerRandomStatic;\nuniform sampler2D samplerRandomDynamic;\nuniform vec2 zOffset;\nuniform vec2 mouse;\nuniform vec3 bgColor;\n\n// == prng =====================================================================\nfloat prng(inout vec4 n)\n{\n  // Based on the post http://gpgpu.org/forums/viewtopic.php?t=2591&sid=17051481b9f78fb49fba5b98a5e0f1f3\n  // (The page no longer exists as of March 17th, 2015. Please let me know if you see why this code works.)\n  const vec4 q = vec4(   1225.0,    1585.0,    2457.0,    2098.0);\n  const vec4 r = vec4(   1112.0,     367.0,      92.0,     265.0);\n  const vec4 a = vec4(   3423.0,    2646.0,    1707.0,    1999.0);\n  const vec4 m = vec4(4194287.0, 4194277.0, 4194191.0, 4194167.0);\n\n  vec4 beta = floor(n / q);\n  vec4 p = a * (n - beta * q) - beta * r;\n  beta = (sign(-p) + vec4(1.0)) * vec4(0.5) * m;\n  n = (p + beta);\n\n  return fract(dot(n / m, vec4(1.0, -1.0, 1.0, -1.0)));\n}\n\nvec3 randomSphere( inout vec4 seed ) {\n  vec3 v;\n  for ( int i = 0; i < 10; i ++ ) {\n    v = vec3(\n      prng( seed ),\n      prng( seed ),\n      prng( seed )\n    ) * 2.0 - 1.0;\n    if ( length( v ) < 1.0 ) { break; }\n  }\n  return v;\n}\n\nvec2 randomCircle( inout vec4 seed ) {\n  vec2 v;\n  for ( int i = 0; i < 10; i ++ ) {\n    v = vec2(\n      prng( seed ),\n      prng( seed )\n    ) * 2.0 - 1.0;\n    if ( length( v ) < 1.0 ) { break; }\n  }\n  return v;\n}\n\nvec3 randomBox( inout vec4 seed ) {\n  vec3 v;\n  v = vec3(\n    prng( seed ),\n    prng( seed ),\n    prng( seed )\n  ) * 2.0 - 1.0;\n  return v;\n}\n\n// == snoise ===================================================================\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat noise4d(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i);\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n// == misc. ====================================================================\nfloat calcDepth( float z ) {\n  return linearstep( perspNear, perspFar, z );\n}\n\nfloat calcDepth( vec3 v ) {\n  return calcDepth( dot( normalize( cameraTar - cameraPos ), v ) );\n}\n\nfloat calcDepthL( vec3 v ) {\n  return calcDepth( dot( normalize( cameraTar - lightPos ), v ) );\n}\n\nvec4 random4( float t ) {\n  return texture2D( samplerRandomStatic, lofi( t * vec2( 0.741, 0.891 ), 1.0 / 2048.0 ) + 0.5 / 2048.0 );\n}\n\nvec4 random4( vec2 v ) {\n  return texture2D( samplerRandomStatic, lofi( v, 1.0 / 2048.0 ) + 0.5 / 2048.0 );\n}\n\nmat2 rotate2D( float _t ) {\n  return mat2( cos( _t ), sin( _t ), -sin( _t ), cos( _t ) );\n}\n\nfloat smin( float a, float b, float k ) {\n  float res = exp( -k * a ) + exp( -k * b );\n  return -log( res ) / k;\n}\n\nvec3 catColor( float _p ) {\n  return 0.5 + 0.5 * vec3(\n    cos( _p ),\n    cos( _p + PI / 3.0 * 4.0 ),\n    cos( _p + PI / 3.0 * 2.0 )\n  );\n}\n\n// == rhythms ==================================================================\nfloat calcRhythms( float aTime, float rawTime ) {\n  // -- glitch -----------------------------------------------------------------\n  {\n    vec4 dice = random4( lofi( aTime, 0.5 beat ) - 4.78 );\n    float thr = (\n      rawTime < SECTION_AAAAA ?\n      0.2 * linearstep( SECTION_AAAAA - 10.0 beat, SECTION_AAAAA, rawTime ) :\n      0.0\n    );\n\n    if ( dice.x < thr ) {\n      aTime -= 0.82 * lofi( mod( aTime, 0.5 beat ), 0.03 );\n    } else if ( dice.x < 2.0 * thr ) {\n      aTime -= 0.95 * lofi( mod( aTime, 0.5 beat ), 0.017 );\n    } else if ( dice.x < 3.0 * thr ) {\n      aTime -= lofi( mod( aTime, 0.5 beat ), 0.125 beat );\n    } else if ( dice.x < 4.0 * thr ) {\n      aTime -= pow( 2.0 * mod( aTime, 0.5 beat ), 2.0 );\n    }\n  }\n\n  // -- kick -------------------------------------------------------------------\n  kickTime = mod( mod( aTime, 2.0 beat ), 0.75 beat );\n  sidechain = smoothstep( 0.0, 0.3, kickTime );\n  kickTime = (\n    rawTime < ( SECTION_ITS_BEGINNING - 8.0 beat ) ? kickTime :\n    rawTime < SECTION_ITS_BEGINNING ? aTime - 8.0 beat :\n    rawTime < ( SECTION_AAAAA - 4.0 beat ) ? mod( aTime, 2.0 beat ) :\n    rawTime < SECTION_AAAAA ? aTime - 12.0 beat :\n    inRange( SECTION_WHAT_THE - 4.0 beat, SECTION_WHAT_THE, rawTime ) ? aTime - 12.0 beat :\n    SECTION_FINISH + 0.75 beat < rawTime ? rawTime - SECTION_FINISH :\n    kickTime\n  );\n  kickTime += 15.75 beat < aTime ? ( aTime - 15.75 beat ) : 0.0;\n\n  // -- rimshot ----------------------------------------------------------------\n  rimshotTime = (\n    inRange( SECTION_HI_RIM, SECTION_ITS_BEGINNING - 4.0 beat, rawTime )\n    ? vec2(\n      mod( mod( mod( aTime, 2.25 beat ), 1.25 beat ), 0.5 beat ),\n      mod( mod( mod( aTime - 0.25 beat, 2.75 beat ), 0.75 beat ), 0.5 beat )\n    )\n    : vec2( 1E9 )\n  );\n\n  // -- clav -------------------------------------------------------------------\n  clavTime = (\n    inRange( SECTION_HI_RIM, SECTION_ITS_BEGINNING, rawTime )\n    ? mod( mod( mod( aTime - 0.75, 3.75 beat ), 2.75 beat ), 0.75 beat )\n    : 1E9\n  );\n\n  // -- hihat ------------------------------------------------------------------\n  hihatTime = mod( aTime, 0.5 beat );\n  vec4 dice = random4( aTime - hihatTime );\n  float trrr = rawTime < SECTION_ITS_BEGINNING ? 1.9 : 2.2;\n  hihatOpen = rawTime < SECTION_ITS_BEGINNING ? 200.0 : mix( 20.0, 200.0, dice.x );\n  hihatTime = mod( hihatTime, 0.5 / pow( 2.0, floor( trrr * dice.z ) ) beat );\n  hihatTime = (\n    inRange( SECTION_ITS_BEGINNING - 4.0 beat, SECTION_AAAAA - 32.0 beat, rawTime ) ?\n    1E9 :\n    hihatTime\n  );\n\n  // -- end --------------------------------------------------------------------\n  return aTime;\n}\n\nvoid calcRhythms() {\n  calcRhythms( mod( time, 16.0 beat ), time );\n}\n"},function(e){e.exports={v:"2.0.1",length:150,resolution:60,params:{"camera-rotY":{nodes:[{time:0,value:0,out:{time:0,value:0}},{time:150,value:0,in:{time:-.5,value:0}}],fxs:[{time:90,length:60,row:0,def:"sine",params:{amp:.1,freq:7,phase:0}}]},"camera-rotX":{nodes:[{time:0,value:0,out:{time:0,value:0}},{time:84,value:0,in:{time:0,value:0},out:{time:5.90382835235873,value:0}},{time:90,value:.1,in:{time:-.48103919876365353,value:0},out:{time:0,value:0}},{time:150,value:.1,in:{time:0,value:0}}],fxs:[{time:90,length:60,row:0,def:"sine",params:{amp:.05,freq:10,phase:0}}]},"post-barrelAmp":{nodes:[{time:0,value:.05,out:{time:0,value:0}},{time:84,value:.05,in:{time:0,value:0},out:{time:5.681300833335072,value:0}},{time:89.82183951568419,value:.36,in:{time:-.13581911075600317,value:0},out:{time:.11926543397217415,value:0}},{time:90.375,value:.05,in:{time:-.5331073535676296,value:0},out:{time:0,value:0}},{time:150,value:.05,in:{time:0,value:0}}],fxs:[]},"post-barrelOffset":{nodes:[{time:0,value:0,out:{time:0,value:0}},{time:150,value:0,in:{time:0,value:0}}],fxs:[]},"camera-Radius":{nodes:[{time:0,value:3,out:{time:0,value:0}},{time:138,value:3,in:{time:0,value:0},out:{time:5.18,value:0}},{time:150,value:7.1000000000000005,in:{time:0,value:0}}],fxs:[]},"dof-amp":{nodes:[{time:0,value:1,out:{time:0,value:0}},{time:150,value:1,in:{time:0,value:0}}],fxs:[]},"dof-focus":{nodes:[{time:0,value:2.5,out:{time:0,value:0}},{time:138,value:2.5,in:{time:0,value:0},out:{time:7.913834203708461,value:0}},{time:150,value:0,in:{time:-4.233974890918859,value:0}}],fxs:[]},"particles-noisePhase":{nodes:[{time:0,value:0,out:{time:0,value:0}},{time:150,value:0,in:{time:0,value:0}}],fxs:[]},"particles-genRate":{nodes:[{time:0,value:0,out:{time:0,value:0}},{time:60,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:90,value:1,in:{time:0,value:0},out:{time:0,value:0}},{time:150,value:1,in:{time:0,value:0}}],fxs:[]},"particles-colorVar":{nodes:[{time:0,value:0,out:{time:0,value:0}},{time:150,value:0,in:{time:0,value:0}}],fxs:[]},"particles-colorOffset":{nodes:[{time:0,value:0,out:{time:0,value:0}},{time:150,value:0,in:{time:0,value:0}}],fxs:[]},"box-posOffset":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:84,value:0,in:{time:0,value:0},out:{time:.5,value:0}},{time:90,value:.2,in:{time:-.5,value:0},out:{time:0,value:0}},{time:150,value:.2,in:{time:0,value:0}}],fxs:[]},"box-spinOffset":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:84,value:0,in:{time:0,value:0},out:{time:.5,value:0}},{time:90,value:.5,in:{time:-.5,value:0},out:{time:0,value:0}},{time:150,value:.5,in:{time:0,value:0}}],fxs:[]},"log-offsetX":{nodes:[{time:0,value:-4.1000000000000005,out:{time:.5,value:0}},{time:150,value:-4.1000000000000005,in:{time:0,value:0}}],fxs:[]},"log-offsetY":{nodes:[{time:0,value:-2.35,out:{time:.5,value:0}},{time:150,value:-2.35,in:{time:-.5,value:0}}],fxs:[]},"log-offsetZ":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:150,value:0,in:{time:-.5,value:0}}],fxs:[]},"camera-fov":{nodes:[{time:0,value:1,out:{time:.5,value:0}},{time:84,value:1,in:{time:-.5,value:0},out:{time:5.499210388713067,value:0}},{time:89.78873216211655,value:1.96,in:{time:-.15237278753981798,value:0},out:{time:.15237278753981798,value:0}},{time:90.375,value:1,in:{time:-.5,value:0},out:{time:0,value:0}},{time:150,value:1,in:{time:-.5,value:0}}],fxs:[]},dzOffset:{nodes:[{time:0,value:1,out:{time:.5,value:0}},{time:84,value:1,in:{time:0,value:0},out:{time:4.501818881948054,value:0}},{time:89.80433128247881,value:20,in:{time:-.5,value:0},out:{time:.2141557941465635,value:0}},{time:90.63765245921151,value:4,in:{time:-.7858442058534365,value:0},out:{time:0,value:0}},{time:150,value:4,in:{time:-.5,value:0}}],fxs:[]},"raymarch-ifsParamsX":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:84,value:.7000000000000001,in:{time:0,value:0},out:{time:4.9658162056481245,value:0}},{time:90,value:1,in:{time:-.5,value:0},out:{time:0,value:0}},{time:150,value:1,in:{time:-.5,value:0}}],fxs:[]},"raymarch-ifsParamsY":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:84,value:0,in:{time:-.5,value:0},out:{time:5.021638908218719,value:0}},{time:90,value:1,in:{time:-1.0582270257060173,value:0},out:{time:0,value:0}},{time:150,value:1,in:{time:-.5,value:0}}],fxs:[]},"raymarch-ifsParamsZ":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:150,value:0,in:{time:-.5,value:0}}],fxs:[]},"raymarch-ifsParamsW":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:150,value:0,in:{time:-.5,value:0}}],fxs:[]},"trails-genRate":{nodes:[{time:0,value:0,out:{time:0,value:0}},{time:30,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:30,value:1,in:{time:0,value:0},out:{time:0,value:0}},{time:54,value:1,in:{time:0,value:0},out:{time:0,value:0}},{time:60,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:150,value:0,in:{time:0,value:0}}],fxs:[]},"trails-noiseScale":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:150,value:0,in:{time:-.5,value:0}}],fxs:[]},"box-size":{nodes:[{time:0,value:.5,out:{time:0,value:0}},{time:84,value:.5,in:{time:0,value:0},out:{time:1.906411162149766,value:0}},{time:90,value:.30000000000000004,in:{time:-2.5946549223507276,value:0},out:{time:0,value:0}},{time:150,value:.30000000000000004,in:{time:0,value:0}}],fxs:[]},"circle-availZ":{nodes:[{time:0,value:10,out:{time:0,value:0}},{time:77.625,value:9.9,in:{time:0,value:0},out:{time:0,value:0}},{time:79.125,value:-20,in:{time:0,value:0},out:{time:0,value:0}},{time:150,value:-20,in:{time:-.5,value:0}}],fxs:[]},"veryPlane-flipThreshold":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:29.625,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:29.625,value:.30000000000000004,in:{time:0,value:0},out:{time:0,value:0}},{time:51,value:.30000000000000004,in:{time:0,value:0},out:{time:0,value:0}},{time:51,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:150,value:0,in:{time:0,value:0}}],fxs:[]},"glitch-amp":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:87.75,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:87.75,value:.01712662045790897,in:{time:0,value:0},out:{time:0,value:0}},{time:87.93634314694167,value:.01709630631347539,in:{time:0,value:0},out:{time:0,value:0}},{time:87.93634314694167,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:88.30578380323469,value:0,in:{time:-.5,value:0},out:{time:0,value:0}},{time:88.5,value:.017778558888035506,in:{time:-.5,value:0},out:{time:0,value:0}},{time:88.5,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:88.67645929948311,value:0,in:{time:0,value:0},out:{time:.8831802607859061,value:.0016742114391677665}},{time:89.795,value:.012529013071470606,in:{time:0,value:0},out:{time:0,value:0}},{time:90.16,value:0,in:{time:-.34742630715584255,value:0},out:{time:0,value:0}},{time:150,value:0,in:{time:-.5,value:0}}],fxs:[]},"glitch-fadeout":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:89.82596046836848,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:89.82596046836848,value:1,in:{time:0,value:0},out:{time:0,value:0}},{time:89.87576725816758,value:1,in:{time:0,value:0},out:{time:.10208270396090313,value:0}},{time:90.13074425441285,value:0,in:{time:-.24965033763372446,value:0},out:{time:0,value:0}},{time:142.5,value:0,in:{time:0,value:0},out:{time:1.841742447483199,value:0}},{time:150,value:1,in:{time:-2.78908745441052,value:0}}],fxs:[]},"patterns-noisePhase":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:150,value:0,in:{time:-.5,value:0}}],fxs:[]},"patterns-genRate":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:114,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:120,value:1,in:{time:0,value:0},out:{time:0,value:0}},{time:150,value:1,in:{time:-.5,value:0}}],fxs:[]},"patterns-colorVar":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:150,value:0,in:{time:-.5,value:0}}],fxs:[]},"patterns-colorOffset":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:150,value:0,in:{time:-.5,value:0}}],fxs:[]},"racer-genRate":{nodes:[{time:0,value:0,out:{time:.5,value:0}},{time:54,value:0,in:{time:0,value:0},out:{time:0,value:0}},{time:90,value:1,in:{time:0,value:0},out:{time:0,value:0}},{time:150,value:1,in:{time:-.5,value:0}}],fxs:[]}},guiSettings:{snapActive:!0,snapTime:.375,snapValue:.1}}},function(e,t){e.exports="precision highp float;\n\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  gl_FragColor = texture2D( sampler0, uv );\n}"},function(e,t){e.exports="#define RADIUS 40.0\n\nuniform vec3 circleColor;\nuniform sampler2D sampler0;\n\nbool print( in vec2 _coord, float _in ) {\n  vec2 coord = _coord;\n\n  // vertical restriction\n  if ( coord.y <= 0.0 || 5.0 <= coord.y ) { return false; }\n  \n  // dot\n  if ( 0.0 < coord.x && coord.x < 2.0 ) {\n    return coord.x < 1.0 && coord.y < 1.0;\n  }\n\n  // padded by dot\n  if ( 2.0 < coord.x ) { coord.x -= 2.0; }\n  \n  // determine digit\n  float ci = floor( coord.x / 5.0 ) + 1.0;\n\n  // too low / too high\n  if ( 4.0 < ci ) { return false; }\n  if ( ci < -4.0 ) { return false; }\n\n  // x of char\n  float cfx = floor( mod( coord.x, 5.0 ) );\n\n  // width is 4\n  if ( 4.0 == cfx ) { return false; }\n\n  // y of char\n  float cfy = floor( coord.y );\n\n  // bit of char\n  float cf = cfx + 4.0 * cfy;\n\n  // determine char  \n  float num = 0.0;\n  if ( 0.0 < ci ) {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( ci < float( i ) ) { break; }\n      \n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n *= 10.0;\n    }\n  } else {\n    float n = abs( _in );\n    for ( int i = 0; i < 6; i ++ ) {\n      if ( -ci < float( i ) ) { break; }\n      \n      if ( ci != 0.0 && n < 1.0 ) {\n        // minus\n        return float( i ) == -ci && _in < 0.0 && cfy == 2.0 && 0.0 < cfx;\n      }\n      num = mod( floor( n ), 10.0 );\n      n -= num;\n      n /= 10.0;\n    }\n  }\n\n  bool a;\n  a = 1.0 == mod( floor( (\n    num == 0.0 ? 432534.0 :\n    num == 1.0 ? 410692.0 :\n    num == 2.0 ? 493087.0 :\n    num == 3.0 ? 493191.0 :\n    num == 4.0 ? 630408.0 :\n    num == 5.0 ? 989063.0 :\n    num == 6.0 ? 399254.0 :\n    num == 7.0 ? 1016898.0 :\n    num == 8.0 ? 431766.0 :\n    433798.0\n  ) / pow( 2.0, cf ) ), 2.0 );\n  \n  return a ? true : false;\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  vec2 m = floor( vec2( 0.0, resolution.y ) + vec2( 1.0, -1.0 ) * mouse );\n  vec2 center = floor( m + vec2( 1.0, 0.7 ) * RADIUS );\n  float circle = length( gl_FragCoord.xy - center ) - RADIUS;\n\n  vec4 col = texture2D( sampler0, uv );\n  vec4 mcol = texture2D( sampler0, ( m + 0.5 ) / resolution );\n  vec4 bcol = vec4( circleColor, 1.0 );\n\n  col = mix(\n    col,\n    mix(\n      bcol,\n      mcol,\n      smoothstep( 1.0, 0.0, circle + 5.0 )\n    ),\n    smoothstep( 1.0, 0.0, circle )\n  );\n\n  if ( circle < 0.0 ) {\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, 8.0 ), mcol.x ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, 0.0 ), mcol.y ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, -8.0 ), mcol.z ) ? bcol : col;\n    col = print( gl_FragCoord.xy - center - vec2( 0.0, -16.0 ), mcol.w ) ? bcol : col;\n  }\n\n  gl_FragColor = col;\n}"},function(e,t){e.exports="void main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  if ( time < 8.0 beat ) {\n    gl_FragColor = vec4( uv, time / ( 8.0 beat ), 1.0 );\n  } else {\n    vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution.y;\n    float radius = 0.3 * exp( -fract( time / ( 1.0 beat ) ) );\n    float shape = linearstep( 2.0 / resolution.y, 0.0, length( p ) - radius );\n    gl_FragColor = vec4( vec3( shape ), 1.0 );\n  }\n}"},function(e,t,n){"use strict";n.r(t);var r=n(0);let a=0,i=[];const o={};let l=!1,s=[0,0,0],u=[.7,.8,1.1];o.line=(()=>{i.push(114514),s[0]=0}),o.print=(e=>{for(let t=0;t<e.length;t++)i.push([s.concat(),u.concat([e.codePointAt(t)])]),s[0]+=.1}),o.code=(e=>{i.push([s.concat(),u.concat([e])]),s[0]+=.1}),o.pos=(e=>{s=e||[0,0,0]}),o.color=(e=>{u=e||[1,1.2,2]}),o.err=(e=>{o.line(),o.color([1.7,.2,.5]),o.print("[ERR!] "),o.color(),o.print(e)}),o.warn=(e=>{o.line(),o.color([1.3,.8,.2]),o.print("[WARN] "),o.color(),o.print(e)}),o.info=(e=>{o.line(),o.color([.2,1.5,.9]),o.print("[INFO] "),o.color(),o.print(e)}),o.verb=(e=>{o.line(),o.color([.5,.1,1]),o.print("[VERB] "),o.color([.6,.6,.6]),o.print(e)}),o.drop=(()=>{i.splice(0),l=!0}),t.default=(e=>{const t=e.glCatPath,s=t.glCat,u=s.gl,f=e.automaton.auto,m=s.createVertexbuffer(new Float32Array(r.c)),c=s.createVertexbuffer(new Float32Array(r.b(32,32).map((e,t)=>t%2==0?(2*e+.5)/32/2:(e+.5)/32))),v=s.createTexture();{const e=new Image;e.onload=(()=>{s.setTexture(v,e),s.textureFilter(v,u.NEAREST)}),e.src=n(15)}const p=s.createTexture();return s.setTextureFromArray(p,1,1,new Uint8Array([0,0,0,0])),t.add({logCompute:{width:64,height:32,vert:n(2),frag:n(16),blend:[u.ONE,u.ZERO],clear:[0,0,0,0],framebuffer:!0,swapbuffer:!0,float:!0,func:(e,t)=>{if(s.uniform1i("logReturn",!1),0<i.length){const e=i.shift();114514===e?s.uniform1i("logReturn",!0):(e[0][3]=a,s.uniform4fv("logPos",e[0]),s.uniform4fv("logCol",e[1]),a=(a+1)%1024)}else s.uniform4fv("logPos",[0,0,0,-1]);s.uniform1i("logDrop",l),l=!1,s.attribute("p",m,2),s.uniform1f("nParticle",1024),s.uniform1f("nParticleSqrt",32),s.uniform1f("ppp",2),s.uniform3fv("logOffset",[f("log-offsetX"),f("log-offsetY"),f("log-offsetZ")]),s.uniformTexture("samplerPcompute",e.swapbuffer.texture,0),s.uniform1f("noisePhase",f("particles-noisePhase")),s.uniform1f("genRate",f("particles-genRate")),u.drawArrays(u.TRIANGLE_STRIP,0,4)}},logRender:{vert:n(17),frag:n(18),blend:[u.ONE,u.ZERO],drawbuffers:3,depthTest:!1,depthWrite:!1,func:(e,n)=>{s.attribute("computeUV",c,2),s.uniform1f("nParticle",1024),s.uniform1f("nParticleSqrt",32),s.uniform1f("ppp",2),s.uniform2fv("resolutionPcompute",[64,32]),s.uniform1i("isShadow",n.isShadow?1:0),s.uniformTexture("samplerPcompute",t.fb("logCompute").texture,0),s.uniformTexture("samplerSprite",v,1),s.uniformTexture("samplerShadow",n.textureShadow||p,2),u.drawArrays(u.POINTS,0,1024)}}}),o})},function(e,t){e.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAABG2lUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS41LjAiPgogPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIi8+CiA8L3JkZjpSREY+CjwveDp4bXBtZXRhPgo8P3hwYWNrZXQgZW5kPSJyIj8+Gkqr6gAAAYNpQ0NQc1JHQiBJRUM2MTk2Ni0yLjEAACiRdZHPK8NhHMdfhshoigPlsDQO2jRT4uIwMQqHmTJctu9+qW2+fb9bWq7KdUWJi18H/gKuylkpIiUHJ2fiwvr6fLfVluzz9Hk+r+f9PJ9Pz/N5wBJIKim9wQ2pdEbz+7z2peCyvekVK920MYAnpOjq3MJUgJr29UCdGe9cZq3a5/41aySqK1DXLDyuqFpGeFp4diOjmrwr3KkkQhHhc2GnJhcUvjf1cInfTI6X+MdkLeCfAEu7sD1exeEqVhJaSlhejiOVzCrl+5gvaY2mFxck9or3oOPHhxc7M0wywQhDjMk8ggsPg7KiRr67mD/PuuQqMqvk0FgjToIMTlGzUj0qMSZ6VEaSnNn/v33VY8OeUvVWLzS+GMZHHzTtQCFvGN/HhlE4gfpnuEpX8tePYPRT9HxFcxyCbQsuritaeA8ut6HrSQ1poaJUL26JxeD9DNqC0HELLSulnpX3OX2EwKZ81Q3sH0C/nLet/gLBYmgPgVKqUQAAAAlwSFlzAAALEwAACxMBAJqcGAAABvRJREFUeJzNW9uW40gIs+fk/3/Z+zLVSxRJiLLTZ3iJTYEQFHVJT+Y8Qrmu61Jj53mea/w8z3PZr2f0R319T+Iye2c34YJ+Hd6fjjgLhglgIPRVxFiMrhjVZkm1WeLycFKboWLWmPVZFpAVKyHjiqGeGXYycUknMl+F53CZ33me54sZJgmsNmZ2k+WKuoXZxcI4Kvk6IWwFMFzEVpN7XdclCzjZZ9IidIlMYqf8VG5sMhO/D75sL6mEcCwhyZahi6P8v6lLReWw5I8zVmBTQmvGljh/Vfw0LuKrlfBUXJsMEmOEFBm3l3WxcJlXrMWX6VJR++SOfARnB0ElrEg4SbvAxXAY7mBKYuNkqElh/GxR2NhuByLWE51/R9eJKuAID0HSfeISwnwYUaVjMRQPNva0tLhdAV2hVAJJgt27GmOTFSW6IRFmYtR1oMNTBZ/wcDHU5DKMxC7hMxIXGAvDEksJfaMDd4sw8tvpQFZQVTxlo+Ikk6Bi7uSW4MjvrkuXXmuqbvfKQgmKmwLTTQW5JuMfcV27p0un6hhe2gGJr9JNcJkPSoJ9XeWPCd1sIIDqwISw6iIWP+lAxsHpMFeXd11VdHWms5nsGZPZd3F37HY4YJyuA5m8Jl/ROjDlm3Sq8p3ugel+yDqL8WZjVd8eIiyJqV3Svc4WD6XkK9XbMjM6hqN82WS+UucndSp5pWMFmgorQDfOaoPvb4dIR/xOt02WIY7dKaKaQJS6pKuP6/LjOI5XBahB085iZBXBRIcJJXEZZ4zRFcJxdHltHyJuD+x0LoHdbmN5qPdpDNadS3/rcJiQ+Y19ViWO76xJVBO1ncv2vl2dwp3idZ9Kl8RWOudrm+QCUcSZHY6lSaSF2imE4zHRpziv45hdPivg+VdQl2BNZOF2+JP4HR7qpZ0CqRVnwdiMJCd5YoebtrLHZ8ZHxWXxnJ2MwZJgCe92V0JwjalT2CXUJeua49HVotb4GnN7htoHla/a25id49VJh83e0Qc5oM7+e6ojl14JJpLcA9M9F3FY1+NWgKsluT69/biI7S3OWRHvfJ19Eney9FROTwn9dZbqBLaPsZlOdQ7f8WDS+XYHUiLpYfOI3Nm7npZuH1Y2Dm89v1Rn7HaWCpRuCe7q0+GhqK1B2bKiqr3zZyyZCTU7afGmMfDTYXTcJtwdB8X5D5I5/4ojt8TdHTupM85mOvFfwmIv/Q4ufjp+0QWZLS9HmvkpW4yPS8RhVCw2hsV1B4jK0eX7NoAdx5aRAlE2Ve+WDNop/W6MJA+22lSMN9vJsmOiCDpbRUZh3IlxF4/5Vs72i3h1mtzv/iVd5Y+F6HQVj+21H8vdtTtbKukymCwXF2OqU++JLuX8YsbJDH+jKxMuLK7TIf5U0u6lG6XSq47Ed2fT+aZ4nc5hOnvWcco/2rw7ci6YSmSS8K6wSXdFZ5+OX/SbPCVo5zZa1F3X/i8iWNwEL+HmcqT5snZNZooFVrN1R1fHGNepr8shecb3Fxtg3wSc3dJPOpAR675RLJ9JXOxOVsREGLY0uKubdDDrDtdRE5l06m4M6fgbxUO/J4qm/BMOnT/ztX/JqK2Pdm7jRqyfYIDL4rqlmWz6SR6JLn22G+ROxzgd64JO0pWgbOpnx6OrBavHx6+zlCQb9xTjWz5LarcsHLZq1DeWqkebn/e0Y1DvujPV7XSk803xJr4d1gvXNtunqm4BqllzhHfkTtej3aSbU7sXK1wNpm79qvVZYJZ40qGMV8XrhB1wjnM3WWz88Q5Mi+VO4TrmCt0Vktm5CWa+XW6PdyCTnQPH+e4efBUvjRtLsqQmvrsxWOe5bux8v2H31oEO4LckXZLLNulANY4xdid/vdM/JqQBur3FEXF3rGob3cUMLydP2NH/J+JE7X2T7mF6hqEmaDpxtWPv+DL5J5ZwV/w746rwT/gex/H+E9/JyVqDMN8drCleF2PnypJeaZbQDkwDd4LLJplRx2Vy2PyW/Py8rX7uXiy7TR91amYZHj6rhNLD7CmRp9+HIVysuy5g3YY6hoe66WpIC61kcsgdh/mJL5J5gojTdzh3uHxT6Ne3D6PmKG+DEP+u8yqvDs91+I5vx/nNl23S6Hj9FdQpH2XbPVesFCPl53gzHqz4DMveA11nuuW0eyVSB1BNdrK/YbGSfbvmmsSwBdzdjCfFS5JjE8LuiOoTY6Wc8Z35v/2bCHaa60AWVC0zjKEIq8Q6PowfdhPGZjaMY8fvbc2z/YDZKgyXvCKU2MTJGKkcGV+W/y1xgK7IqE9slY/6TPE6zh1eUtSP/2hzHP//W8RqcQyAexHT1/EuIcTC2JNDqdo5XopPGufrksy48kntJzx2sJIO3L5sOt3Su/eE/FOdMOnEqfwHNmIjIwDn6G0AAAAASUVORK5CYII="},function(e,t){e.exports="uniform float nParticleSqrt;\nuniform float nParticle;\nuniform float ppp;\n\nuniform sampler2D samplerPcompute;\n\nuniform vec4 logPos;\nuniform vec3 logOffset;\nuniform vec4 logCol;\nuniform bool logReturn;\nuniform bool logDrop;\n\n// ------\n\nvec4 sampleRandom( vec2 _uv ) {\n  return texture2D( samplerRandomDynamic, _uv );\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 puv = vec2( ( floor( gl_FragCoord.x / ppp ) * ppp + 0.5 ) / resolution.x, uv.y );\n  float mode = mod( gl_FragCoord.x, ppp );\n  vec2 dpix = vec2( 1.0 ) / resolution;\n\n  // == prepare some vars ======================================================\n  vec4 seed = texture2D( samplerRandomStatic, puv );\n  prng( seed );\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 col = texture2D( samplerPcompute, puv + dpix * vec2( 1.0, 0.0 ) );\n\n  float index = floor( uv.x * nParticleSqrt ) + floor( uv.y * nParticleSqrt ) * nParticleSqrt;\n\n  if ( logPos.w == index ) {\n    // == generate particles ===================================================\n    pos = logPos;\n    pos.xyz += logOffset;\n    pos.w = 0.0; // lifetime\n\n    col = logCol;\n  }\n\n  // == update particles =======================================================\n  pos.y += logReturn ? 0.12 : 0.0;\n  pos.w += deltaTime + ( logDrop ? 1E9 : 0.0 );\n\n  gl_FragColor = (\n    mode < 1.0 ? pos :\n    col\n  );\n}"},function(e,t){e.exports="attribute vec2 computeUV;\n\nvarying vec4 vPos;\nvarying vec3 vCol;\nvarying vec2 vUv;\nvarying float vSize;\n\nuniform vec2 resolutionPcompute;\n\nuniform bool isShadow;\n\nuniform float colorVar;\nuniform float colorOffset;\n\nuniform sampler2D samplerPcompute;\n\nvoid main() {\n  // == fetch compute texture ==================================================\n  vec2 puv = computeUV;\n  vec2 dppix = vec2( 1.0 ) / resolutionPcompute;\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 col = texture2D( samplerPcompute, puv + dppix * vec2( 1.0, 0.0 ) );\n\n  // == geometry ===============================================================\n  float kickBeat = exp( -10.0 * mod( mod( time, 2.0 beat ), 0.75 beat ) );\n\n  vSize = 0.042 * (\n    ( 1.0 - exp( -10.0 * pos.w ) ) *\n    smoothstep( 10.0, 9.0, pos.w )\n  );\n\n  // == special chars ==========================================================\n  if ( col.w == 3.0 ) { // \n    float wave = 0.5 + 0.5 * sin( 10.0 * pos.x + 10.0 * time );\n    col = vec4( mix(\n      col.xyz,\n      vec3( 1.8, 0.1, 0.5 ),\n      wave\n    ), 3.0 );\n    vSize *= 1.0 + 0.5 * wave;\n  } else if ( col.w == 14.0 ) { // \n    float b = exp( -5.0 * mod( mod( time, 2.0 beat ), 0.75 beat ) );\n    col = vec4( mix(\n      col.xyz,\n      vec3( 1.8, 0.8, 3.8 ),\n      kickBeat\n    ), 14.0 );\n    vSize *= 1.0 + kickBeat;\n  } else if ( col.w == 2.0 ) { // \n    col = vec4( mix(\n      vec3( 1.1, 0.5, 0.1 ),\n      vec3( 0.7, 1.4, 0.3 ),\n      floor( mod( totalFrame, 4.0 ) / 2.0 )\n    ), 2.0 );\n  }\n\n  // == assign varying variables ===============================================\n  vCol = col.xyz;\n  float ch = col.w;\n  vUv = floor( vec2( mod( ch, 16.0 ), col.w / 16.0 ) );\n\n  // == finalize ===============================================================\n  vPos = pos;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * vec4( pos.xyz, 1.0 );\n  } else {\n    outPos = matP * matV * vec4( pos.xyz, 1.0 );\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n  gl_PointSize = vSize * resolution.y / outPos.z / tan( perspFov * PI / 360.0 );\n}"},function(e,t){e.exports="#extension GL_EXT_draw_buffers : require\n\nvarying vec4 vPos;\nvarying vec3 vCol;\nvarying vec2 vUv;\nvarying float vSize;\n\nuniform bool isShadow;\n\nuniform sampler2D samplerSprite;\n\n// == main procedure ===========================================================\nvoid main() {\n  if ( vSize == 0.0 ) { discard; }\n\n  vec2 uv = ( gl_PointCoord + vUv ) / 16.0;\n  float tex = texture2D( samplerSprite, uv ).x;\n  if ( tex < 0.5 ) { discard; }\n\n  if ( isShadow ) {\n    gl_FragData[ 0 ] = vec4( calcDepthL( vPos.xyz - lightPos ), 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  gl_FragData[ 0 ] = vec4( vPos.xyz, 1.0 );\n  gl_FragData[ 1 ] = vec4( 0.0, 0.0, 1.0, 1.0 );\n  gl_FragData[ 2 ] = vec4( vCol, 2.0 );\n}"},function(e,t,n){"use strict";n.r(t);var r=n(0);t.default=(e=>{const t=e.glCatPath,a=t.glCat,i=a.gl,o=e.width,l=e.height,s=a.createVertexbuffer(new Float32Array(r.c));t.add({preBloom:{width:o/4,height:l/4,vert:n(2),frag:n(20),blend:[i.ONE,i.ONE],clear:[0,0,0,0],framebuffer:!0,float:!0,func:(e,t)=>{a.attribute("p",s,2),a.uniform3fv("bias",t.bias),a.uniform3fv("factor",t.factor),a.uniformTexture("sampler0",t.input,0),i.drawArrays(i.TRIANGLE_STRIP,0,4)}},bloom:{width:o/4,height:l/4,vert:n(2),frag:n(21),blend:[i.ONE,i.ONE],clear:[0,0,0,0],framebuffer:!0,float:!0,tempFb:a.createFloatFramebuffer(o/4,l/4),func:(e,n)=>{a.attribute("p",s,2);for(let r=0;r<3;r++){let o=[3,10,50][r];a.uniform1f("var",o),i.bindFramebuffer(i.FRAMEBUFFER,e.tempFb.framebuffer),a.clear(...e.clear),a.uniform1i("isVert",!1),a.uniformTexture("sampler0",0===r?t.fb("preBloom").texture:e.framebuffer.texture,0),i.drawArrays(i.TRIANGLE_STRIP,0,4),i.bindFramebuffer(i.FRAMEBUFFER,n.framebuffer),a.uniform1i("isVert",!0),a.uniformTexture("sampler0",e.tempFb.texture,0),i.drawArrays(i.TRIANGLE_STRIP,0,4)}}},postBloom:{width:o,height:l,vert:n(2),frag:n(22),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,float:!0,func:(e,n)=>{a.attribute("p",s,2),a.uniformTexture("samplerDry",n.dry,0),a.uniformTexture("samplerWet",t.fb("bloom").texture,1),i.drawArrays(i.TRIANGLE_STRIP,0,4)}}})})},function(e,t){e.exports="uniform vec3 bias;\nuniform vec3 factor;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 deltaTexel = 0.25 / resolution;\n  vec2 uvOrigin = ( floor( gl_FragCoord.xy ) + deltaTexel * 0.5 ) / resolution;\n\n  vec3 sum = vec3( 0.0 );\n  for ( int iy = 0; iy < 4; iy ++ ) {\n    for ( int ix = 0; ix < 4; ix ++ ) {\n      vec2 uv = uvOrigin + vec2( ix, iy ) * deltaTexel;\n      sum += texture2D( sampler0, uv ).xyz / 16.0;\n    }\n  }\n\n  gl_FragColor = vec4(\n    max( vec3( 0.0 ), ( sum + bias ) * factor ),\n    1.0\n  );\n}\n"},function(e,t){e.exports="#define SAMPLES 20\n#define MUL_THR 0.01\n\n// ------\n\nuniform bool isVert;\nuniform sampler2D sampler0;\n\nuniform float var;\n\nfloat gaussian( float _x, float _v ) {\n  return 1.0 / sqrt( 2.0 * PI * _v ) * exp( - _x * _x / 2.0 / _v );\n}\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  if ( var <= 0.0 ) {\n    gl_FragColor = texture2D( sampler0, uv );\n    return;\n  }\n\n  vec2 bv = ( isVert ? vec2( 0.0, 1.0 ) : vec2( 1.0, 0.0 ) ) / resolution;\n\n  vec3 sum = vec3( 0.0 );\n  for ( int i = 0; i <= SAMPLES; i ++ ) {\n    float mul = gaussian( abs( float( i ) ), var );\n    if ( mul < MUL_THR ) { break; }\n    for ( int j = -1; j < 2; j += 2 ) {\n      vec2 v = saturate( uv + bv * float( i * j ) );\n      vec3 tex = texture2D( sampler0, v ).xyz;\n      sum += tex * mul;\n      if ( i == 0 ) { break; }\n    }\n  }\n\n  gl_FragColor = vec4( sum, 1.0 );\n}\n"},function(e,t){e.exports="uniform sampler2D samplerDry;\nuniform sampler2D samplerWet;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec3 dry = texture2D( samplerDry, uv ).xyz;\n  vec3 wet = texture2D( samplerWet, uv ).xyz;\n  gl_FragColor = vec4( saturate( dry + wet ), 1.0 );\n}\n"},function(e,t,n){"use strict";n.r(t);var r=n(1),a=n(0),i=n(7),o=n.n(i);t.default=(e=>{const t=e.glCatPath,i=t.glCat,l=i.gl,s=e.automaton.auto,u=o()(),f=i.createVertexbuffer(new Float32Array(u.position)),m=i.createVertexbuffer(new Float32Array(u.normal)),c=i.createIndexbuffer(new Int16Array(u.index)),v=a.b(11,11).map((e,t)=>e/5-1),p=i.createVertexbuffer(new Float32Array(v));t.add({box:{vert:n(24),frag:n(25),blend:[l.ONE,l.ZERO],drawbuffers:3,func:(e,t)=>{i.attribute("aPos",f,3),i.attribute("aNor",m,3),i.attributeDivisor("aMatrix",p,2,1),i.uniform1i("isShadow",t.isShadow),i.uniform1f("size",s("box-size")),i.uniform1f("posOffset",s("box-posOffset")),i.uniform1f("spinOffset",s("box-spinOffset"));let n=r.a.mat4Identity();i.uniformMatrix4fv("matM",n);let a=i.getExtension("ANGLE_instanced_arrays");l.bindBuffer(l.ELEMENT_ARRAY_BUFFER,c),a.drawElementsInstancedANGLE(l.TRIANGLES,u.index.length,l.UNSIGNED_SHORT,0,v.length/2),l.bindBuffer(l.ELEMENT_ARRAY_BUFFER,null)}}})})},function(e,t){e.exports="// == attributes ===============================================================\nattribute vec3 aPos;\nattribute vec3 aNor;\nattribute vec2 aMatrix;\n\n// == varyings =================================================================\nvarying vec3 vPos;\nvarying vec3 vNor;\n\nuniform bool isShadow;\n\nuniform float posOffset;\nuniform float spinOffset;\nuniform float size;\n\nuniform mat4 matM;\n\n// == main =====================================================================\nvoid main() {\n  calcRhythms();\n\n  vec4 pos = vec4( ( 1.0 + 0.2 * sin( PI * exp( -10.0 * kickTime ) ) ) * size * aPos, 1.0 );\n  pos.yz = rotate2D( spinOffset * aMatrix.x + 1.3 * time ) * pos.yz;\n  pos.zx = rotate2D( spinOffset * aMatrix.y + 0.7 * time ) * pos.zx;\n  pos.xy += posOffset * aMatrix;\n  pos = matM * pos;\n  vPos = pos.xyz;\n\n  vec4 nor = vec4( aNor, 0.0 );\n  nor.yz = rotate2D( spinOffset * aMatrix.x + 1.3 * time ) * nor.yz;\n  nor.zx = rotate2D( spinOffset * aMatrix.y + 0.7 * time ) * nor.zx;\n  nor = normalize( matM * nor );\n  vNor = nor.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * pos;\n  } else {\n    outPos = matP * matV * pos;\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n}"},function(e,t){e.exports="// == shit =====================================================================\n#extension GL_EXT_draw_buffers : require\n\n// == varyings =================================================================\nvarying vec3 vPos;\nvarying vec3 vNor;\n\n// == uniforms =================================================================\nuniform bool isShadow;\n\n// == main =====================================================================\nvoid main() {\n  if ( isShadow ) {\n    gl_FragData[ 0 ] = vec4( calcDepthL( vPos - lightPos ), 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  gl_FragData[ 0 ] = vec4( vPos, 1.0 );\n  gl_FragData[ 1 ] = vec4( vNor, 1.0 );\n  gl_FragData[ 2 ] = vec4( 0.01, 0.03, 0.1, 3.0 );\n}"},function(e,t,n){"use strict";n.r(t);n(3);var r=n(0);n(1);t.default=(e=>{const t=e.glCatPath,a=t.glCat,i=a.gl,o=e.automaton.auto,l=n(27)({radius:1,hole:.8}),s=a.createVertexbuffer(l.position),u=a.createVertexbuffer(l.uv),f=a.createVertexbuffer(l.normal),m=a.createVertexbuffer(new Float32Array(r.a(30))),c=a.createIndexbuffer(l.index);t.add({circle:{vert:n(28),frag:n(29),blend:[i.ONE,i.ZERO],cull:!1,drawbuffers:3,func:(e,t)=>{a.attribute("aPos",s,3),a.attribute("aUv",u,2),a.attribute("aNor",f,3),a.attributeDivisor("aMatrix",m,1,1),a.uniform1i("isShadow",t.isShadow),a.uniform1f("availZ",o("circle-availZ")),a.uniform3fv("color",[1,.1,.3]);let n=a.getExtension("ANGLE_instanced_arrays");i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,c),n.drawElementsInstancedANGLE(i.TRIANGLES,l.index.length,i.UNSIGNED_SHORT,0,30),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,null)}}})})},function(e,t){e.exports=(e=>{let t=Object.assign({radius:1,hole:.5,segments:16},e),n=new Float32Array(6*t.segments),r=new Float32Array(4*t.segments),a=new Float32Array(6*t.segments),i=new Int16Array(6*t.segments),o=t.radius,l=t.hole,s=t.hole/t.radius;const u=2*Math.PI/t.segments;for(let e=0;e<t.segments;e++){const f=e*u,m=Math.cos(f),c=Math.sin(f);n.set([m*l,c*l,0,m*o,c*o,0],6*e),r.set([.5+.5*m*s,.5+.5*c*s,.5+.5*m,.5+.5*c],4*e),a.set([0,0,1,0,0,1],6*e);const v=2*e,p=v+1,d=e===t.segments-1?0:2*e+2,h=d+1;i.set([v,p,h,v,h,d],6*e)}return{position:n,uv:r,normal:a,index:i}})},function(e,t){e.exports="// == attributes ===============================================================\nattribute vec3 aPos;\nattribute vec2 aUv;\nattribute vec3 aNor;\nattribute float aMatrix;\n\n// == varyings =================================================================\nvarying vec3 vPos;\nvarying vec2 vUv;\nvarying vec3 vNor;\nvarying float vScale;\nvarying float vPattern;\n\n// == uniforms =================================================================\nuniform bool isShadow;\n\n// == main =====================================================================\nvoid main() {\n  vec4 pos = vec4( aPos, 1.0 );\n  pos.z += mod( aMatrix + zOffset.x, 30.0 ) - 20.0;\n  vPos = pos.xyz;\n\n  float rot = time * zp2mp( random4( aMatrix * 0.4 + 0.1 ).x );\n  pos.xy = rotate2D( rot ) * pos.xy;\n\n  vUv = aUv;\n  vScale = 1.5;\n  vPattern = mod( aMatrix, 3.0 );\n\n  vec4 nor = normalize( vec4( aNor, 0.0 ) );\n  vNor = nor.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * pos;\n  } else {\n    outPos = matP * matV * pos;\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n}"},function(e,t){e.exports="#extension GL_EXT_draw_buffers : require\n\n// == varyings =================================================================\nvarying vec3 vPos;\nvarying vec2 vUv;\nvarying vec3 vNor;\nvarying float vScale;\nvarying float vPattern;\n\n// == uniforms =================================================================\nuniform bool isShadow;\nuniform float availZ;\n\n// == main =====================================================================\nvoid main() {\n  if ( isShadow ) {\n    gl_FragData[ 0 ] = vec4( calcDepthL( vPos - lightPos ), 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  if (\n    vPos.z < availZ ||\n    inRange( availZ + 0.5, availZ + 1.0, vPos.z )\n  ) { discard; }\n\n  // this bool means visibility\n  bool b = false;\n\n  vec2 uv = vUv;\n\n  if ( vPattern < 0.5 ) {\n    vec2 uv = abs( uv - 0.5 );\n    b = (\n      ( uv.x < 0.15 / vScale ) ? (\n        ( uv.y - 0.45 < 0.03 / vScale ) &&\n        !( ( uv.y - 0.45 ) - ( uv.x - 0.025 / vScale ) * sqrt( 3.0 ) < 0.0 )\n      ) : abs( length( uv ) - 0.45 ) < 0.01 / vScale\n    );\n  } else if ( vPattern < 1.5 ) {\n    vec2 uv = uv - 0.5;\n    b = (\n      abs( fract( atan( uv.y, uv.x ) * 40.0 / PI ) - 0.5 ) < 0.2 / vScale / length( uv ) &&\n      abs( length( uv ) - 0.45 ) < 0.05 / vScale\n    );\n  } else if ( vPattern < 2.5 ) {\n    vec2 uv = abs( uv - 0.5 );\n    b = (\n      abs( length( uv ) - 0.45 ) < 0.04 / vScale &&\n      0.1 / vScale < min( uv.x, uv.y ) ||\n      abs( length( uv ) - 0.47 ) < 0.01 / vScale\n    );\n  }\n\n  if ( !b ) { discard; }\n\n  gl_FragData[ 0 ] = vec4( vPos, 1.0 );\n  gl_FragData[ 1 ] = vec4( vNor, 1.0 );\n  gl_FragData[ 2 ] = vec4( 2.0, 0.0, 0.0, 4.0 );\n}"},function(e,t,n){"use strict";n.r(t);var r=n(0);t.default=(e=>{const t=e.glCatPath,a=t.glCat,i=a.gl,o=e.width,l=e.height,s=a.createVertexbuffer(new Float32Array(r.c));t.add({distance:{width:o,height:l,vert:n(2),frag:n(31),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,float:!0,func:(e,t)=>{a.attribute("p",s,2),a.uniformTexture("sampler0",t.input,0),i.drawArrays(i.TRIANGLE_STRIP,0,4)}}})})},function(e,t){e.exports="uniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec4 pos = texture2D( sampler0, uv );\n  gl_FragColor = vec4( calcDepth( pos.xyz - cameraPos ), 0.0, 0.0, 1.0 );\n}"},function(e,t,n){"use strict";n.r(t);var r=n(0);t.default=(e=>{const t=e.glCatPath,a=t.glCat,i=a.gl,o=e.width,l=e.height,s=e.automaton.auto,u=a.createVertexbuffer(new Float32Array(r.c));t.add({dof:{width:o,height:l,vert:n(2),frag:n(33),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,float:!0,func:(e,t)=>{a.attribute("p",u,2),a.uniform1f("bokehAmp",s("dof-amp")),a.uniform1f("bokehFocus",s("dof-focus")),a.uniformTexture("samplerDry",t.dry,0),a.uniformTexture("samplerDepth",t.depth,1),i.drawArrays(i.TRIANGLE_STRIP,0,4)}}})})},function(e,t){e.exports="// Ref: https://www.shadertoy.com/view/4d2Xzw\n\n#define FOG_ONE calcDepth(5.0)\n#define FOG_ZERO calcDepth(20.0)\n#define BOKEH_ITER 20\n#define BOKEH_ANGLE 2.39996\n#define BOKEH_RADIUS_MAX (resolution.x / 64.0)\n\nuniform sampler2D samplerDry;\nuniform sampler2D samplerDepth;\n\nuniform float bokehAmp;\nuniform float bokehFocus;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  float radiusPerStep = BOKEH_RADIUS_MAX / float( BOKEH_ITER );\n  float radius = radiusPerStep * 1E-5; // EPSILON\n  vec4 seed = texture2D( samplerRandomDynamic, uv );\n  prng( seed ); // mix well\n  prng( seed ); // mix well\n  vec2 nOffset = vec2( 0.0, 1.0 ) * rotate2D( TAU * prng( seed ) );\n  mat2 rotator = rotate2D( BOKEH_ANGLE );\n\n  vec4 sum = vec4( 0.0 );\n\n  for ( int i = 0; i < BOKEH_ITER; i ++ ) {\n    vec2 uv = ( gl_FragCoord.xy + nOffset * radius ) / resolution;\n    vec3 col = texture2D( samplerDry, uv ).xyz;\n    float len = texture2D( samplerDepth, uv ).x;\n\n    col = mix( bgColor.xyz, col, linearstep( FOG_ZERO, FOG_ONE, len ) );\n\n    float r = min( max( abs( 1.0 / len - 1.0 / calcDepth( bokehFocus ) ) * bokehAmp, 1E-2 ), BOKEH_RADIUS_MAX );\n    float amp = 1.0 / ( r / BOKEH_RADIUS_MAX * float( BOKEH_ITER ) );\n    amp *= linearstep( radius, radius + radiusPerStep, r );\n    sum += vec4( col, 1.0 ) * amp;\n\n    nOffset = rotator * nOffset;\n    radius += radiusPerStep;\n  }\n\n  gl_FragColor = vec4( sum.xyz / sum.w, 1.0 );\n}\n"},function(e,t,n){"use strict";n.r(t);var r=n(3),a=n(0);new r.a(15881342356);t.default=(e=>{const t=e.glCatPath,r=t.glCat,i=r.gl,o=e.automaton.auto,l=r.createVertexbuffer(new Float32Array(a.c)),s=r.createVertexbuffer(new Float32Array(a.d)),u=r.createVertexbuffer(new Float32Array(a.b(8,8).map((e,t)=>t%2==0?(1*e+.5)/8/1:(e+.5)/8))),f=r.createTexture();r.setTextureFromArray(f,1,1,new Uint8Array([0,0,0,0])),t.add({patternsCompute:{width:8,height:8,vert:n(2),frag:n(35),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,swapbuffer:!0,float:!0,func:(e,t)=>{r.attribute("p",l,2),r.uniform1f("nParticle",64),r.uniform1f("nParticleSqrt",8),r.uniform1f("ppp",1),r.uniformTexture("samplerPcompute",e.swapbuffer.texture,0),r.uniform1f("noisePhase",o("patterns-noisePhase")),r.uniform1f("genRate",o("patterns-genRate")),i.drawArrays(i.TRIANGLE_STRIP,0,4)}},patternsRender:{vert:n(36),frag:n(37),blend:[i.ONE,i.ZERO],drawbuffers:3,func:(e,n)=>{r.attribute("aPos",s,3),r.attributeDivisor("aComputeUV",u,2,1),r.uniform1f("nParticle",64),r.uniform1f("nParticleSqrt",8),r.uniform1f("ppp",1),r.uniform2fv("resolutionPcompute",[8,8]),r.uniform1i("isShadow",n.isShadow?1:0),r.uniformTexture("samplerPcompute",t.fb("patternsCompute").texture,0),r.uniformTexture("samplerShadow",n.textureShadow||f,1),r.getExtension("ANGLE_instanced_arrays").drawArraysInstancedANGLE(i.TRIANGLE_STRIP,0,4,64)}}})})},function(e,t){e.exports="#define PARTICLE_LIFE_LENGTH 0.5\n\nuniform float nParticleSqrt;\nuniform float nParticle;\nuniform float ppp;\n\nuniform sampler2D samplerPcompute;\n\nuniform float genRate;\n\n// ------\n\nvec2 vInvert( vec2 _uv ) {\n  return vec2( 0.0, 1.0 ) + vec2( 1.0, -1.0 ) * _uv;\n}\n\n// ------\n\nvec4 sampleRandom( vec2 _uv ) {\n  return texture2D( samplerRandomDynamic, _uv );\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 puv = vec2( ( floor( gl_FragCoord.x / ppp ) * ppp + 0.5 ) / resolution.x, uv.y );\n  float mode = mod( gl_FragCoord.x, ppp );\n  vec2 dpix = vec2( 1.0 ) / resolution;\n\n  float dt = deltaTime;\n\n  // == prepare some vars ======================================================\n  vec4 seed = texture2D( samplerRandomDynamic, puv );\n  prng( seed );\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n\n  float timing = mix( 0.0, PARTICLE_LIFE_LENGTH, floor( puv.y * nParticleSqrt ) / nParticleSqrt );\n  timing += lofi( time, PARTICLE_LIFE_LENGTH );\n\n  if ( time - deltaTime + PARTICLE_LIFE_LENGTH < timing ) {\n    timing -= PARTICLE_LIFE_LENGTH;\n  }\n\n  // == generate particles =====================================================\n  if (\n    time - deltaTime < timing && timing <= time &&\n    prng( seed ) < genRate\n  ) {\n    dt = time - timing;\n\n    pos.xyz = 3.0 * randomBox( seed ) - vec3( 0.0, 0.0, 2.0 );\n    pos.w = 1.0; // life\n  } else {\n    // == update particles =====================================================\n    pos.z += zOffset.y * dt;\n    pos.w -= dt / PARTICLE_LIFE_LENGTH;\n  }\n\n  gl_FragColor = pos;\n}"},function(e,t){e.exports="attribute vec3 aPos;\nattribute vec2 aComputeUV;\n\nvarying vec3 vPos;\nvarying vec3 vRawPos;\nvarying vec3 vCol;\nvarying float vLife;\nvarying float vMode;\n\nuniform vec2 resolutionPcompute;\n\nuniform bool isShadow;\n\nuniform float colorVar;\nuniform float colorOffset;\n\nuniform sampler2D samplerPcompute;\n\nvoid main() {\n  // == fetch compute texture ==================================================\n  vec2 puv = aComputeUV;\n  vec2 dppix = vec2( 1.0 ) / resolutionPcompute;\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n\n  // == ???????? ===============================================================\n  vec4 dice = texture2D( samplerRandomStatic, puv.xy * 182.92 );\n\n  // == assign varying variables ===============================================\n  vLife = pos.w;\n\n  // vCol = (\n  //   dice.y < 0.8\n  //   ? pow( catColor( TAU * ( ( dice.x * 2.0 - 1.0 ) * colorVar + colorOffset ) ), vec3( 2.0 ) )\n  //   : vec3( 0.4 )\n  // );\n  // vCol = abs( vel.xyz );\n  vCol = 2.0 * exp( 2.3 * ( vLife - 1.0 ) ) * catColor( 6.9 + 2.0 * ( 1.0 - vLife ) );\n\n  // == geometry ===============================================================\n  float size = 0.2;\n  pos.xyz += aPos * size;\n  vRawPos = aPos;\n  vMode = floor( 4.0 * dice.y );\n\n  // == finalize ===============================================================\n  vPos = pos.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * vec4( pos.xyz, 1.0 );\n  } else {\n    outPos = matP * matV * vec4( pos.xyz, 1.0 );\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n}"},function(e,t){e.exports="#extension GL_EXT_draw_buffers : require\n\nvarying vec3 vPos;\nvarying vec3 vCol;\nvarying vec3 vRawPos;\nvarying float vLife;\nvarying float vMode;\n\nuniform bool isShadow;\n\nuniform sampler2D samplerShadow;\n\n// == patterns =================================================================\nbool ptn0( vec2 _p ) {\n  float inner = pow( 1.0 - vLife, 2.0 );\n  float outer = 1.0 - exp( -5.0 * ( 1.0 - vLife ) );\n  vec2 p = _p;\n  return inner < length( p ) && length( p ) < outer;\n}\n\nbool ptn1( vec2 _p ) {\n  float inner = 0.7 * pow( 1.0 - vLife, 2.0 );\n  float outer = 0.7 * ( 1.0 - exp( -5.0 * ( 1.0 - vLife ) ) );\n  vec2 p = _p * rotate2D( PI * ( 1.0 - exp( -2.0 * ( 1.0 - vLife ) ) ) );\n  return (\n    max( abs( p.x ), abs( p.y ) ) < outer &&\n    inner < max( abs( p.x ), abs( p.y ) )\n  );\n}\n\nbool ptn2( vec2 _p ) {\n  float inner = 0.7 * pow( 1.0 - vLife, 2.0 );\n  float outer = 0.7 * ( 1.0 - exp( -5.0 * ( 1.0 - vLife ) ) );\n  vec2 p = _p * rotate2D( PI / 4.0 );\n  return (\n    max( abs( p.x ), abs( p.y ) ) < outer &&\n    inner < min( abs( p.x ), abs( p.y ) )\n  );\n}\n\nbool ptn3( vec2 _p ) {\n  float inner = 0.3 * ( 1.0 - pow( 1.0 - vLife, 2.0 ) );\n  float outer = 0.3 * ( ( 1.0 - exp( -5.0 * ( 1.0 - vLife ) ) ) );\n  float radius = 0.7 * ( ( 1.0 - exp( -5.0 * ( 1.0 - vLife ) ) ) );\n  \n  vec2 p = _p;\n  p = rotate2D( -PI / 2.0 ) * p;\n  p = rotate2D( -lofir( atan( p.y, p.x ), TAU / 6.0 ) ) * p;\n  p.x -= radius * ( ( 1.0 - exp( -5.0 * ( 1.0 - vLife ) ) ) );\n  return (\n    length( p ) < inner &&\n    length( p ) < outer\n  );\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  if ( vLife <= 0.0 ) { discard; }\n\n  // if ( 0.5 < length( gl_PointCoord - 0.5 ) ) { discard; }\n\n  if ( isShadow ) {\n    gl_FragData[ 0 ] = vec4( calcDepthL( vPos - lightPos ), 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  vec2 p = vRawPos.xy;\n  bool b = false;\n\n  if ( vMode < 0.5 ) {\n    b = b || ptn0( p );\n\n  } else if ( vMode < 1.5 ) {\n    b = b || ptn1( p );\n\n  } else if ( vMode < 2.5 ) {\n    b = b || ptn2( p );\n\n  } else {\n    b = b || ptn3( p );\n\n  }\n\n  if ( !b ) { discard; }\n\n  gl_FragData[ 0 ] = vec4( vPos, 1.0 );\n  gl_FragData[ 1 ] = vec4( 0.0, 0.0, 1.0, 1.0 );\n  gl_FragData[ 2 ] = vec4( 1.7, 0.8, 1.1, 2.0 );\n}"},function(e,t,n){"use strict";n.r(t);var r=n(3),a=n(0);new r.a(15881342356);t.default=(e=>{const t=e.glCatPath,r=t.glCat,i=r.gl,o=e.automaton.auto,l=r.createVertexbuffer(new Float32Array(a.c)),s=r.createVertexbuffer(new Float32Array(a.b(512,512).map((e,t)=>t%2==0?(2*e+.5)/512/2:(e+.5)/512))),u=r.createTexture();r.setTextureFromArray(u,1,1,new Uint8Array([0,0,0,0])),t.add({particlesCompute:{width:1024,height:512,vert:n(2),frag:n(39),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,swapbuffer:!0,float:!0,func:(e,t)=>{r.attribute("p",l,2),r.uniform1f("nParticle",262144),r.uniform1f("nParticleSqrt",512),r.uniform1f("ppp",2),r.uniformTexture("samplerPcompute",e.swapbuffer.texture,0),r.uniform1f("noisePhase",o("particles-noisePhase")),r.uniform1f("genRate",o("particles-genRate")),i.drawArrays(i.TRIANGLE_STRIP,0,4)}},particlesRender:{vert:n(40),frag:n(41),blend:[i.ONE,i.ZERO],drawbuffers:3,func:(e,n)=>{r.attribute("computeUV",s,2),r.uniform1f("nParticle",262144),r.uniform1f("nParticleSqrt",512),r.uniform1f("ppp",2),r.uniform2fv("resolutionPcompute",[1024,512]),r.uniform1i("isShadow",n.isShadow?1:0),r.uniform1f("colorVar",o("particles-colorVar")),r.uniform1f("colorOffset",o("particles-colorOffset")),r.uniformTexture("samplerPcompute",t.fb("particlesCompute").texture,0),r.uniformTexture("samplerShadow",n.textureShadow||u,1),i.drawArrays(i.POINTS,0,262144)}}})})},function(e,t){e.exports="#define PARTICLE_LIFE_LENGTH 3.0\n\nuniform float nParticleSqrt;\nuniform float nParticle;\nuniform float ppp;\n\nuniform sampler2D samplerPcompute;\n\nuniform float noisePhase;\nuniform float velScale;\nuniform float genRate;\n\n// ------\n\nvec2 vInvert( vec2 _uv ) {\n  return vec2( 0.0, 1.0 ) + vec2( 1.0, -1.0 ) * _uv;\n}\n\n// ------\n\nvec4 sampleRandom( vec2 _uv ) {\n  return texture2D( samplerRandomDynamic, _uv );\n}\n\n// ------\n\nvoid main() {\n  calcRhythms();\n\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 puv = vec2( ( floor( gl_FragCoord.x / ppp ) * ppp + 0.5 ) / resolution.x, uv.y );\n  float mode = mod( gl_FragCoord.x, ppp );\n  vec2 dpix = vec2( 1.0 ) / resolution;\n\n  float dt = deltaTime;\n\n  // == prepare some vars ======================================================\n  vec4 seed = texture2D( samplerRandomDynamic, puv );\n  prng( seed );\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dpix * vec2( 1.0, 0.0 ) );\n\n  float timing = mix( 0.0, PARTICLE_LIFE_LENGTH, floor( puv.y * nParticleSqrt ) / nParticleSqrt );\n  timing += lofi( time, PARTICLE_LIFE_LENGTH );\n\n  if ( time - deltaTime + PARTICLE_LIFE_LENGTH < timing ) {\n    timing -= PARTICLE_LIFE_LENGTH;\n  }\n\n  // == generate particles =====================================================\n  if (\n    time - deltaTime < timing && timing <= time &&\n    prng( seed ) < genRate\n  ) {\n    dt = time - timing;\n\n    pos.xyz = 4.0 * randomSphere( seed ) - vec3( 0.0, 0.0, 5.0 );\n\n    vel.xyz = 0.0 * randomSphere( seed );\n    vel.w = 0.0;\n\n    pos.w = 1.0; // life\n  } else {\n    // == update particles =======================================================\n    vel.xyz += dt * ( 10.0 + 20.0 * exp( -5.0 * kickTime ) ) * vec3(\n      noise4d( vec4( 0.8 * pos.xyz, 1.485 + 0.1 * time ) ),\n      noise4d( vec4( 0.8 * pos.xyz, 3.485 + 0.1 * time ) ),\n      noise4d( vec4( 0.8 * pos.xyz, 5.485 + 0.1 * time ) )\n    );\n    vel.xyz += 4.0 * dt * smoothstep( 3.0, 1.5, length( pos.xyz ) ) * normalize( pos.xyz );\n    vel.xyz *= exp( -5.0 * dt );\n\n    pos.xyz += vel.xyz * dt;\n    pos.z += zOffset.y * dt;\n    pos.w -= dt / PARTICLE_LIFE_LENGTH;\n  }\n\n  gl_FragColor = (\n    mode < 1.0 ? pos :\n    vel\n  );\n}"},function(e,t){e.exports="attribute vec2 computeUV;\n\nvarying vec3 vPos;\nvarying vec3 vCol;\nvarying float vLife;\n\nuniform vec2 resolutionPcompute;\n\nuniform bool isShadow;\n\nuniform float colorVar;\nuniform float colorOffset;\n\nuniform sampler2D samplerPcompute;\n\nvoid main() {\n  // == fetch compute texture ==================================================\n  vec2 puv = computeUV;\n  vec2 dppix = vec2( 1.0 ) / resolutionPcompute;\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dppix * vec2( 1.0, 0.0 ) );\n\n  // == ???????? ===============================================================\n  vec4 dice = texture2D( samplerRandomStatic, puv.xy * 182.92 );\n\n  // == assign varying variables ===============================================\n  vLife = pos.w;\n\n  // vCol = (\n  //   dice.y < 0.8\n  //   ? pow( catColor( TAU * ( ( dice.x * 2.0 - 1.0 ) * colorVar + colorOffset ) ), vec3( 2.0 ) )\n  //   : vec3( 0.4 )\n  // );\n  // vCol = abs( vel.xyz );\n  vCol = 2.0 * exp( 2.3 * ( vLife - 1.0 ) ) * catColor( 6.9 + 2.0 * ( 1.0 - vLife ) );\n\n  // == geometry ===============================================================\n  float size = ( 0.001 + 0.01 * pow( dice.w, 6.0 ) ) * pow( sin( PI * vLife ), 0.25 );\n\n  // == finalize ===============================================================\n  vPos = pos.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * vec4( pos.xyz, 1.0 );\n  } else {\n    outPos = matP * matV * vec4( pos.xyz, 1.0 );\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n  gl_PointSize = resolution.y * size / outPos.z / tan( perspFov * PI / 360.0 );\n}"},function(e,t){e.exports="#extension GL_EXT_draw_buffers : require\n\nvarying vec3 vPos;\nvarying vec3 vCol;\nvarying float vLife;\n\nuniform bool isShadow;\n\nuniform sampler2D samplerShadow;\n\n// == main procedure ===========================================================\nvoid main() {\n  if ( vLife <= 0.0 ) { discard; }\n\n  if ( 0.5 < length( gl_PointCoord - 0.5 ) ) { discard; }\n\n  if ( isShadow ) {\n    gl_FragData[ 0 ] = vec4( calcDepthL( vPos - lightPos ), 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  gl_FragData[ 0 ] = vec4( vPos, 1.0 );\n  gl_FragData[ 1 ] = vec4( 0.0, 0.0, 1.0, 1.0 );\n  gl_FragData[ 2 ] = vec4( 0.8, 0.9, 2.0, 4.0 );\n}"},function(e,t,n){"use strict";n.r(t);var r=n(0);t.default=(e=>{const t=e.glCatPath,a=t.glCat,i=a.gl,o=e.width,l=e.height,s=e.automaton.auto,u=a.createVertexbuffer(new Float32Array(r.c));t.add({post:{width:o,height:l,vert:n(2),frag:n(43),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,float:!0,func:(e,t)=>{a.attribute("p",u,2),a.uniform1f("barrelAmp",s("post-barrelAmp")),a.uniform1f("barrelOffset",s("post-barrelOffset")),a.uniformTexture("sampler0",t.input,0),i.drawArrays(i.TRIANGLE_STRIP,0,4)}},glitch:{width:o,height:l,vert:n(2),frag:n(44),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,float:!0,func:(e,t)=>{a.attribute("p",u,2),a.uniform1f("amp",s("glitch-amp")),a.uniform1f("fadeout",s("glitch-fadeout")),a.uniformTexture("sampler0",t.input,0),i.drawArrays(i.TRIANGLE_STRIP,0,4)}},fxaa:{width:o,height:l,vert:n(2),frag:n(45),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,float:!0,func:(e,t)=>{a.attribute("p",u,2),a.uniformTexture("sampler0",t.input,0),i.drawArrays(i.TRIANGLE_STRIP,0,4)}}})})},function(e,t){e.exports="#define BARREL_ITER 10\n\n// == uniforms =================================================================\nuniform float barrelAmp;\nuniform float barrelOffset;\nuniform sampler2D sampler0;\n\n// == distort a coordination and sample a texture ==============================\nvec3 barrel( float amp, vec2 uv ) {\n  float corn = length( vec2( 0.5 ) );\n  float a = min( 3.0 * sqrt( amp ), corn * PI );\n  float zoom = corn / ( tan( corn * a ) + corn );\n  vec2 p = saturate(\n    ( uv + normalize( uv - 0.5 ) * tan( length( uv - 0.5 ) * a ) ) * zoom +\n    0.5 * ( 1.0 - zoom )\n  );\n  return texture2D( sampler0, vec2( p.x, p.y ) ).xyz;\n}\n\n// == main =====================================================================\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution.y;\n\n  // == glitch =================================================================\n  vec3 tex = vec3( 0.0 );\n\n  // == do barrel distortion ===================================================\n  for ( int i = 0; i < BARREL_ITER; i ++ ) {\n    float fi = ( float( i ) + 0.5 ) / float( BARREL_ITER );\n    vec3 a = saturate( vec3(\n      1.0 - 3.0 * abs( 1.0 / 6.0 - fi ),\n      1.0 - 3.0 * abs( 1.0 / 2.0 - fi ),\n      1.0 - 3.0 * abs( 5.0 / 6.0 - fi )\n    ) ) / float( BARREL_ITER ) * 4.0;\n    tex += a * barrel( barrelOffset + barrelAmp * fi, uv );\n  }\n\n  // == do vignette ============================================================\n  float vig = 1.0 - length( p ) * 0.4;\n  tex = mix( vec3( 0.0 ), tex, vig );\n\n  // == do color correction ====================================================\n  vec3 col = pow( saturate( tex.xyz ), vec3( 1.0 / 1.6 ) );\n  col = vec3(\n    smoothstep( 0.00, 1.00, col.x ),\n    col.y,\n    0.1 + 0.8 * col.z\n  );\n\n  // == done ===================================================================\n  gl_FragColor = vec4( col, 1.0 );\n}"},function(e,t){e.exports="uniform float amp;\nuniform float fadeout;\nuniform sampler2D sampler0;\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 uv2 = uv;\n  for ( int i = 0; i < 5; i ++ ) {\n    float p = pow( 2.0, float( i ) );\n    uv2 += amp * vec2( 1.0, 0.0 ) * zp2mp(\n      random4( uv2 / vec2( 256.0, 128.0 ) * p + 0.5 * mod( totalFrame, 2.0 ) ).xy\n    ) / p;\n  }\n  vec2 displace = uv2 - uv;\n  displace += 0.2 * fadeout * vec2( zp2mp( random4( lofi( uv.y, 1.0 / 48.0 ) ).x ), 0.0 );\n  gl_FragColor = vec4( ( 1.0 - fadeout ) * vec3(\n    texture2D( sampler0, fract( uv + displace ) ).x,\n    texture2D( sampler0, fract( uv + 1.2 * displace ) ).y,\n    texture2D( sampler0, fract( uv + 1.4 * displace ) ).z\n  ), 1.0 );\n}"},function(e,t){e.exports="#define FXAA_REDUCE_MIN (1.0 / 128.0)\n#define FXAA_REDUCE_MUL (1.0 / 8.0)\n#define FXAA_SPAN_MAX 16.0\n\n// ------\n\nprecision highp float;\n\nuniform sampler2D sampler0;\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n\n  #define T(v) texture2D( sampler0, (v) / resolution ).xyz\n  vec3 rgb11 = T( gl_FragCoord.xy );\n  vec3 rgb00 = T( gl_FragCoord.xy + vec2( -1.0, -1.0 ) );\n  vec3 rgb02 = T( gl_FragCoord.xy + vec2( -1.0,  1.0 ) );\n  vec3 rgb20 = T( gl_FragCoord.xy + vec2(  1.0, -1.0 ) );\n  vec3 rgb22 = T( gl_FragCoord.xy + vec2(  1.0,  1.0 ) );\n  #undef T\n\n  vec3 luma = vec3( 0.299, 0.587, 0.114 );\n  #define L(c) dot( c, luma )\n  float luma11 = L( rgb11 );\n  float luma00 = L( rgb00 );\n  float luma02 = L( rgb02 );\n  float luma20 = L( rgb20 );\n  float luma22 = L( rgb22 );\n  #undef L\n\n  float lumaMin = min( luma00, min( min( luma00, luma02 ), min( luma20, luma22 ) ) );\n  float lumaMax = max( luma00, max( max( luma00, luma02 ), max( luma20, luma22 ) ) );\n\n  vec2 dir = vec2(\n    -( ( luma00 + luma20 ) - ( luma02 + luma22 ) ),\n    ( ( luma00 + luma02 ) - ( luma20 + luma22 ) )\n  );\n\n  float dirReduce = max(\n    ( luma00 + luma02 + luma20 + luma22 ) * 0.25 * FXAA_REDUCE_MUL,\n    FXAA_REDUCE_MIN\n  );\n  float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n  dir = min(\n    vec2( FXAA_SPAN_MAX ),\n    max(\n      vec2( -FXAA_SPAN_MAX ),\n      dir * rcpDirMin\n    )\n  ) / resolution;\n\n  vec3 rgbA = 0.5 * (\n    texture2D( sampler0, uv + dir * ( 1.0 / 3.0 - 0.5 ) ).xyz +\n    texture2D( sampler0, uv + dir * ( 2.0 / 3.0 - 0.5 ) ).xyz\n  );\n  vec3 rgbB = rgbA * 0.5 + 0.25 * (\n    texture2D( sampler0, uv - dir * 0.5 ).xyz +\n    texture2D( sampler0, uv + dir * 0.5 ).xyz\n  );\n\n  float lumaB = dot( rgbB, luma );\n  gl_FragColor = (\n    ( ( lumaB < lumaMin ) || ( lumaMax < lumaB ) ) ?\n    vec4( rgbA, 1.0 ) :\n    vec4( rgbB, 1.0 )\n  );\n}"},function(e,t,n){"use strict";n.r(t);var r=n(3),a=n(0);new r.a(15881342356);t.default=(e=>{const t=e.glCatPath,r=t.glCat,i=r.gl,o=e.automaton.auto,l=r.createVertexbuffer(new Float32Array(a.c)),s=r.createVertexbuffer(new Float32Array(a.b(64,256).map((e,t)=>t%2==0?(2*e+.5)/64/2:(e+.5)/256))),u=r.createTexture();r.setTextureFromArray(u,1,1,new Uint8Array([0,0,0,0])),t.add({racerCompute:{width:128,height:256,vert:n(2),frag:n(47),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,swapbuffer:!0,float:!0,func:(e,t)=>{r.attribute("p",l,2),r.uniform1f("trails",256),r.uniform1f("trailLength",64),r.uniform1f("ppp",2),r.uniformTexture("samplerPcompute",e.swapbuffer.texture,0),r.uniform1f("genRate",o("racer-genRate")),i.drawArrays(i.TRIANGLE_STRIP,0,4)}},racerRender:{vert:n(48),frag:n(49),blend:[i.ONE,i.ZERO],drawbuffers:3,func:(e,n)=>{r.attribute("aComputeUV",s,2),r.uniform1f("trails",256),r.uniform1f("trailLength",64),r.uniform1f("ppp",2),r.uniform2fv("resolutionPcompute",[128,256]),r.uniform1i("isShadow",n.isShadow?1:0),r.uniformTexture("samplerPcompute",t.fb("racerCompute").texture,0),r.uniformTexture("samplerShadow",n.textureShadow||u,1),i.drawArrays(i.POINTS,0,16384)}}})})},function(e,t){e.exports="#define PARTICLE_LIFE_LENGTH 3.0\n\nuniform float trails;\nuniform float trailLength;\nuniform float ppp;\n\nuniform sampler2D samplerPcompute;\nuniform float genRate;\n\n// ------\n\nvec2 vInvert( vec2 _uv ) {\n  return vec2( 0.0, 1.0 ) + vec2( 1.0, -1.0 ) * _uv;\n}\n\n// ------\n\nvec4 random( vec2 _uv ) {\n  return texture2D( samplerRandomDynamic, _uv );\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 puv = vec2( ( floor( gl_FragCoord.x / ppp ) * ppp + 0.5 ) / resolution.x, uv.y );\n  float mode = mod( gl_FragCoord.x, ppp );\n  vec2 dpix = vec2( 1.0 ) / resolution;\n\n  float dt = deltaTime;\n\n  // == if it is not head of particles =========================================\n  if ( ppp < gl_FragCoord.x ) {\n    puv.x -= ppp / resolution.x;\n    vec4 pos = texture2D( samplerPcompute, puv );\n    vec4 vel = texture2D( samplerPcompute, puv + dpix * vec2( 1.0, 0.0 ) );\n\n    pos.z += zOffset.y * dt;\n    pos.w = saturate( pos.w - 1.0 / trailLength );\n\n    gl_FragColor = (\n      mode < 1.0 ? pos :\n      vel\n    );\n    return;\n  }\n\n  // == prepare some vars for fuck around head particle ========================\n  vec4 seed = texture2D( samplerRandomDynamic, puv );\n  prng( seed );\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dpix * vec2( 1.0, 0.0 ) );\n\n  float timing = mix( 0.0, PARTICLE_LIFE_LENGTH, floor( puv.y * trails ) / trails );\n  timing += lofi( time, PARTICLE_LIFE_LENGTH );\n\n  if ( time - deltaTime + PARTICLE_LIFE_LENGTH < timing ) {\n    timing -= PARTICLE_LIFE_LENGTH;\n  }\n\n  // == initialize particles ===================================================\n  if (\n    time - deltaTime < timing && timing <= time\n  ) {\n    dt = time - timing;\n\n    pos.xyz = 2.0 * randomSphere( seed ) - vec3( 0.0, 0.0, zOffset.y );\n\n    vel.xyz = 1.0 * randomSphere( seed );\n    vel.w = 1.0; // jumping flag\n\n    pos.w = prng( seed ) < genRate ? 1.0 : 0.0; // life\n  } else {\n    vel.w = 0.0; // remove jumping flag\n  }\n\n  // == update particles =======================================================\n  vel.xyz += 10.0 * vec3(\n    noise4d( vec4( 0.4 * pos.xyz, 1.845 + 0.1 * time ) ),\n    noise4d( vec4( 0.4 * pos.xyz, 2.853 + 0.1 * time ) ),\n    noise4d( vec4( 0.4 * pos.xyz, 4.129 + 0.1 * time ) )\n  ) * dt;\n  vel.xy += 4.0 * dt * smoothstep( 2.0, 1.0, length( pos.xy ) ) * normalize( pos.xy );\n  vel.xyz *= exp( -1.0 * dt );\n\n  vec3 velt = vel.xyz;\n  velt.x *= abs( velt.x ) < abs( velt.y ) ? 0.0 : abs( velt.x ) < abs( velt.z ) ? 0.0 : 1.0;\n  velt.y *= abs( velt.y ) < abs( velt.z ) ? 0.0 : abs( velt.y ) < abs( velt.x ) ? 0.0 : 1.0;\n  velt.z *= abs( velt.z ) < abs( velt.x ) ? 0.0 : abs( velt.z ) < abs( velt.y ) ? 0.0 : 1.0;\n\n  pos.xyz += normalize( velt ) * 0.04;\n  pos.z += zOffset.y * dt;\n\n  gl_FragColor = (\n    mode < 1.0 ? pos :\n    vel\n  );\n}"},function(e,t){e.exports="attribute vec2 aComputeUV;\n\nvarying vec3 vPos;\nvarying float vLife;\n\nuniform float trails;\nuniform float trailLength;\nuniform float ppp;\n\nuniform bool isShadow;\n\nuniform float colorVar;\nuniform float colorOffset;\n\nuniform sampler2D samplerPcompute;\n\nvoid main() {\n  // == fetch compute texture ==================================================\n  vec2 puv = aComputeUV;\n  vec2 dppix = vec2( 1.0 ) / vec2( trailLength, trails );\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dppix * vec2( 1.0, 0.0 ) );\n\n  // == ???????? ===============================================================\n  vec4 dice = texture2D( samplerRandomStatic, puv.xy * 182.92 );\n\n  // == assign varying variables ===============================================\n  vLife = pos.w;\n\n  // == finalize ===============================================================\n  vPos = pos.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * vec4( pos.xyz, 1.0 );\n  } else {\n    outPos = matP * matV * vec4( pos.xyz, 1.0 );\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n  gl_PointSize = resolution.y * 0.01 / outPos.z / tan( perspFov * PI / 360.0 );\n}"},function(e,t){e.exports="#extension GL_EXT_draw_buffers : require\n\nvarying vec3 vPos;\nvarying vec3 vCol;\nvarying float vLife;\n\nuniform bool isShadow;\n\nuniform sampler2D samplerShadow;\n\n// == main procedure ===========================================================\nvoid main() {\n  if ( vLife <= 0.0 ) { discard; }\n\n  if ( 0.5 < length( gl_PointCoord - 0.5 ) ) { discard; }\n\n  if ( isShadow ) {\n    gl_FragData[ 0 ] = vec4( calcDepthL( vPos - lightPos ), 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  float lumi = (\n    1.3 +\n    4.0 * exp( -3.0 * ( 1.0 - vLife ) ) +\n    9.0 * exp( -20.0 * ( 1.0 - vLife ) )\n  );\n\n  gl_FragData[ 0 ] = vec4( vPos, 1.0 );\n  gl_FragData[ 1 ] = vec4( 0.0, 0.0, 1.0, 1.0 );\n  gl_FragData[ 2 ] = vec4( lumi, 0.0, 0.0, 4.0 );\n}"},function(e,t,n){"use strict";n.r(t);var r=n(0);t.default=(e=>{const t=e.glCatPath,a=t.glCat,i=a.gl,o=(e.width,e.height,e.automaton.auto),l=a.createVertexbuffer(new Float32Array(r.c));t.add({raymarch:{vert:n(2),frag:n(51),blend:[i.ONE,i.ZERO],drawbuffers:3,func:(e,t)=>{a.attribute("p",l,2),a.uniform1i("isShadow",t.isShadow?1:0),a.uniform4fv("ifsParams",[o("raymarch-ifsParamsX"),o("raymarch-ifsParamsY"),o("raymarch-ifsParamsZ"),o("raymarch-ifsParamsW")]),i.drawArrays(i.TRIANGLE_STRIP,0,4)}}})})},function(e,t){e.exports="#extension GL_EXT_frag_depth : require\n#extension GL_EXT_draw_buffers : require\n\n#define TRACE_ITER 1\n#define MARCH_MUL 0.8\n#define MARCH_ITER 80\n#define RAYLEN_INIT 0.01\n#define INTERSECT_MIN 0.001\n#define MARCH_FAR 20.0\n#define FOV 90.0\n\nuniform bool isShadow;\nuniform vec4 ifsParams;\n\n// ------\n\nstruct Camera {\n  vec3 pos;\n  vec3 dir;\n  vec3 sid;\n  vec3 top;\n  float fov;\n};\n\nstruct Ray {\n  vec3 dir;\n  vec3 ori;\n};\n\n// ------\n\nCamera camInit( in vec3 _pos, in vec3 _tar, in float _rot, in float _fov ) {\n  Camera cam;\n  cam.pos = _pos;\n  cam.dir = normalize( _tar - _pos );\n  cam.sid = normalize( cross( cam.dir, vec3( 0.0, 1.0, 0.0 ) ) );\n  cam.top = normalize( cross( cam.sid, cam.dir ) );\n  cam.sid = cos( _rot ) * cam.sid + sin( _rot ) * cam.top;\n  cam.top = normalize( cross( cam.sid, cam.dir ) );\n  cam.fov = _fov;\n\n  return cam;\n}\n\nRay rayInit( in vec3 _ori, in vec3 _dir ) {\n  Ray ray;\n  ray.dir = _dir;\n  ray.ori = _ori;\n  return ray;\n}\n\nRay rayFromCam( in vec2 _p, in Camera _cam ) {\n  vec3 dir = normalize(\n    _p.x * _cam.sid\n    + _p.y * _cam.top\n    + _cam.dir / tan( _cam.fov * PI / 360.0 ) // Is this correct?\n  );\n  return rayInit( _cam.pos, dir );\n}\n\n// ------\n\nfloat distBox( vec3 _p, vec3 _s ) {\n  vec3 d = abs( _p ) - _s;\n  return min( max( d.x, max( d.y, d.z ) ), 0.0 ) + length( max( d, 0.0 ) );\n}\n\nvec3 typeIfs( vec3 _p, vec3 _rot, vec3 _shift ) {\n  vec3 pos = _p;\n\n  vec3 shift = _shift;\n\n  for ( int i = 0; i < 5; i ++ ) {\n    float intensity = pow( 2.0, -float( i ) );\n\n    pos = abs( pos ) - shift * intensity;\n\n    shift.yz = rotate2D( _rot.x ) * shift.yz;\n    shift.zx = rotate2D( _rot.y ) * shift.zx;\n    shift.xy = rotate2D( _rot.z ) * shift.xy;\n\n    if ( pos.x < pos.y ) { pos.xy = pos.yx; }\n    if ( pos.x < pos.z ) { pos.xz = pos.zx; }\n    if ( pos.y < pos.z ) { pos.yz = pos.zy; }\n  }\n\n  return pos;\n}\n\nfloat distFunc( vec3 _p, out vec4 mtl ) {\n  float dist = 1E9;\n\n  vec3 p = _p - vec3( 0.0, 0.0, zOffset.x );\n\n  {\n    vec3 p = mod( p, 2.0 ) - 1.0;\n    float ch = min( distBox( p, vec3( 0.1, 0.01, 0.01 ) ), distBox( p, vec3( 0.01, 0.1, 0.01 ) ) );\n\n    mtl = ch < dist ? vec4( 0.8, 0.8, 0.8, 1.0 ) : mtl;\n    dist = ch < dist ? ch : dist;\n  }\n\n\n  if ( 224.0 beat < time ) {\n    vec3 p = p;\n    p.z = mod( p.z - 2.5, 5.0 ) - 2.5;\n    p = typeIfs( p, vec3( -0.01, 0.06, -0.01 ), vec3( ifsParams.x * 4.8, ifsParams.x * 6.8, 4.8 ) );\n    float ch = 1.8 * distBox( p / 1.8, vec3( ifsParams.y * 0.2 ) );\n\n    mtl = ch < dist ? vec4( 0.02, 0.05, 0.08, 3.0 ) : mtl;\n    dist = ch < dist ? ch : dist;\n  }\n\n  if ( 224.0 beat < time ) {\n    vec3 p = p;\n    p.z = mod( p.z - 1.0, 2.0 ) - 1.0;\n    p = typeIfs( p, vec3( 0.02, -0.13, 0.01 ), vec3( ifsParams.x * 11.4, ifsParams.x * 4.8, 5.1 ) );\n    float ch = distBox( p, vec3( ifsParams.y * 0.4 ) );\n\n    mtl = ch < dist ? vec4( 0.02, 0.05, 0.08, 3.0 ) : mtl;\n    dist = ch < dist ? ch : dist;\n  }\n\n  return dist;\n}\n\nfloat distFunc( vec3 _p ) {\n  vec4 dummy;\n  return distFunc( _p, dummy );\n}\n\nvec3 normalFunc( in vec3 _p, in float _d ) {\n  vec2 d = vec2( 0.0, _d );\n  return normalize( vec3(\n    distFunc( _p + d.yxx ) - distFunc( _p - d.yxx ),\n    distFunc( _p + d.xyx ) - distFunc( _p - d.xyx ),\n    distFunc( _p + d.xxy ) - distFunc( _p - d.xxy )\n  ) );\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / resolution.y;\n\n  Camera cam = camInit(\n    isShadow ? lightPos : cameraPos,\n    cameraTar,\n    isShadow ? 0.0 : cameraRoll,\n    perspFov\n  );\n  Ray ray = rayFromCam( p, cam );\n\n  float rayLen = RAYLEN_INIT;\n  vec3 rayPos = ray.ori + ray.dir * rayLen;\n  vec4 mtl;\n\n  float dist;\n  for ( int iMarch = 0; iMarch < MARCH_ITER; iMarch ++ ) {\n    dist = distFunc( rayPos, mtl );\n    rayLen += dist * MARCH_MUL;\n    rayPos = ray.ori + ray.dir * rayLen;\n\n    if ( dist < INTERSECT_MIN ) { break; }\n    if ( MARCH_FAR < dist ) { break; }\n  }\n\n  vec3 normal = vec3( 0.0 );\n  if ( dist < INTERSECT_MIN ) {\n    normal = normalFunc( rayPos, 1E-4 );\n\n    float z = dot( normalize( cameraTar - cam.pos ), rayPos - cam.pos );\n    float a = ( perspFar + perspNear ) / ( perspFar - perspNear );\n    float b = 2.0 * perspFar * perspNear / ( perspFar - perspNear );\n    gl_FragDepthEXT = 0.5 + 0.5 * ( a - b / z );\n  } else {\n    gl_FragDepthEXT = 1.0;\n  }\n\n  if ( isShadow ) {\n    gl_FragData[ 0 ] = vec4( calcDepthL( rayPos - lightPos ), 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  gl_FragData[ 0 ] = vec4( rayPos, 1.0 );\n  gl_FragData[ 1 ] = vec4( normal, 1.0 );\n  gl_FragData[ 2 ] = mtl;\n}"},function(e,t,n){"use strict";n.r(t);var r=n(0);t.default=(e=>{const t=e.glCatPath,a=t.glCat,i=a.gl,o=e.width,l=e.height,s=a.createVertexbuffer(new Float32Array(r.c));t.add({render:{width:o,height:l,vert:n(2),frag:n(53),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,float:!0,func:(e,t)=>{a.attribute("p",s,2),a.uniformTexture("sampler0",t.inputs[0],0),a.uniformTexture("sampler1",t.inputs[1],1),a.uniformTexture("sampler2",t.inputs[2],2),a.uniformTexture("samplerShadow",t.shadow,3),i.drawArrays(i.TRIANGLE_STRIP,0,4)}}})})},function(e,t){e.exports="// == uniforms =================================================================\nuniform sampler2D sampler0;\nuniform sampler2D sampler1;\nuniform sampler2D sampler2;\nuniform sampler2D samplerShadow;\n\n// == struct: isect ============================================================\nstruct Isect {\n  vec3 pos;\n  vec3 nor;\n  int mtl;\n  vec4 props;\n};\n\nIsect getIsect( vec2 _uv ) {\n  vec4 tex0 = texture2D( sampler0, _uv );\n  vec4 tex1 = texture2D( sampler1, _uv );\n  vec4 tex2 = texture2D( sampler2, _uv );\n\n  Isect isect;\n  isect.pos = tex0.xyz;\n  isect.nor = tex1.xyz;\n  isect.mtl = int( tex2.w );\n  isect.props = vec4( tex2.xyz, fract( floor( tex2.w ) ) );\n\n  return isect;\n}\n\nfloat getEdge( vec2 _uv ) {\n  vec4 tex0 = texture2D( sampler0, _uv - vec2( 0.0, 0.0 ) / resolution );\n  vec4 tex1 = texture2D( sampler1, _uv - vec2( 0.0, 0.0 ) / resolution );\n  vec4 tex2 = texture2D( sampler2, _uv - vec2( 0.0, 0.0 ) / resolution );\n  vec3 ray = tex0.xyz - cameraPos;\n  vec3 rayDir = normalize( ray );\n  float rayLen = length( ray );\n\n  float f = mod( gl_FragCoord.x + gl_FragCoord.y, 2.0 ) < 1.0 ? 1.0 : -1.0;\n  vec4 tex0x = texture2D( sampler0, _uv + vec2( f, 0.0 ) / resolution );\n  vec4 tex0y = texture2D( sampler0, _uv + vec2( 0.0, f ) / resolution );\n  vec4 tex1x = texture2D( sampler1, _uv + vec2( f, 0.0 ) / resolution );\n  vec4 tex1y = texture2D( sampler1, _uv + vec2( 0.0, f ) / resolution );\n  vec4 tex2x = texture2D( sampler2, _uv + vec2( f, 0.0 ) / resolution );\n  vec4 tex2y = texture2D( sampler2, _uv + vec2( 0.0, f ) / resolution );\n\n  float validx = tex2.w == tex2x.w ? 1.0 : 0.0;\n  float validy = tex2.w == tex2y.w ? 1.0 : 0.0;\n\n  return (\n    abs( dot( rayDir, tex0x.xyz ) - dot( rayDir, tex0.xyz ) ) / rayLen * validx +\n    abs( dot( rayDir, tex0y.xyz ) - dot( rayDir, tex0.xyz ) ) / rayLen * validy +\n    length( tex1x.xyz - tex1.xyz ) * validx +\n    length( tex1y.xyz - tex1.xyz ) * validy\n  );\n}\n\n// == shadow ===================================================================\nfloat shadow( Isect _isect ) {\n  vec3 lig = _isect.pos - lightPos;\n  float d = max( 0.001, dot( -_isect.nor, normalize( lig ) ) );\n\n  vec4 pl = matPL * matVL * vec4( _isect.pos, 1.0 );\n  vec2 uv = pl.xy / pl.w * 0.5 + 0.5;\n\n  float dc = calcDepthL( lig );\n  float ret = 0.0;\n  for ( int iy = -1; iy <= 1; iy ++ ) {\n    for ( int ix = -1; ix <= 1; ix ++ ) {\n      vec2 uv = uv + vec2( float( ix ), float ( iy ) ) * 1E-3;\n      float proj = texture2D( samplerShadow, uv ).x;\n      float bias = 0.001 + ( 1.0 - d ) * 0.003;\n\n      float dif = mix(\n        smoothstep( bias * 2.0, bias, abs( dc - proj ) ),\n        1.0,\n        smoothstep( 0.4, 0.5, max( abs( uv.x - 0.5 ), abs( uv.y - 0.5 ) ) )\n      );\n      ret += dif / 9.0;\n    }\n  }\n  return ret;\n}\n\n// == do shading ===============================================================\nvec3 radiance( Isect _isect, vec3 dif, vec3 spe, float rough ) {\n  // Ref: https://www.shadertoy.com/view/lsXSz7\n\n  // calc a bunch of vectors\n  vec3 ligDir = normalize( _isect.pos - lightPos );\n  vec3 viewDir = normalize( _isect.pos - cameraPos );\n  vec3 halfDir = normalize( ligDir + viewDir );\n\n  float dotLig = max( 0.001, dot( -_isect.nor, ligDir ) );\n  float dotView = max( 0.001, dot( -_isect.nor, viewDir ) );\n  float dotHalf = max( 0.001, dot( -_isect.nor, halfDir ) );\n  float dotHalfView = max( 0.001, dot( halfDir, viewDir ) );\n\n  // Cook-Torrance\n  float G = min( 1.0, 2.0 * dotHalf * min( dotView, dotLig ) / dotHalfView );\n\n  // Beckmann\n  float sqDotHalf = dotHalf * dotHalf;\n  float sqDotHalfRough = sqDotHalf * rough * rough;\n  float D = exp( ( sqDotHalf - 1.0 ) / sqDotHalfRough ) / ( sqDotHalf * sqDotHalfRough );\n\n  // Fresnel\n  vec3 Fspe = spe + ( 1.0 - spe ) * pow( 1.0 - dotHalfView, 5.0 );\n  vec3 Fdif = spe + ( 1.0 - spe ) * pow( 1.0 - dotLig, 5.0 );\n\n  // BRDF\n  vec3 brdfSpe = Fspe * D * G / ( dotView * dotLig * 4.0 );\n  vec3 brdfDif = dif * ( 1.0 - Fdif );\n\n  // shadow\n  float sh = mix( 0.6, 1.0, shadow( _isect ) );\n\n  return ( brdfSpe + brdfDif ) * lightCol * dotLig * sh;\n}\n\n// == main =====================================================================\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  Isect isect = getIsect( uv );\n\n  // if there are no normal, it's an air\n  if ( length( isect.nor ) < 0.5 ) {\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  vec3 thisColorIsCool = 0.2 + 0.8 * catColor(\n    3.0 + smoothstep( -5.0, 2.0, isect.pos.z )\n  );\n\n  // material\n  vec3 col;\n  if ( isect.mtl == 1 ) {\n    col = radiance( isect, isect.props.xyz, vec3( 0.1 ), 0.2 );\n  } else if ( isect.mtl == 2 ) {\n    col = isect.props.xyz;\n  } else if ( isect.mtl == 3 ) {\n    col = radiance( isect, isect.props.xyz, vec3( 0.2 ), 0.2 );\n    col += 2.4 * thisColorIsCool * smoothstep( 0.03, 0.2, getEdge( uv ) );\n  } else if ( isect.mtl == 4 ) {\n    col = isect.props.x * thisColorIsCool;\n  }\n\n  gl_FragColor = vec4( col, 1.0 );\n}"},function(e,t,n){"use strict";n.r(t);var r=n(3),a=n(0);new r.a(15881342356);t.default=(e=>{const t=e.glCatPath,r=t.glCat,i=r.gl,o=e.automaton.auto,l=r.createVertexbuffer(new Float32Array(a.c)),s=r.createVertexbuffer((()=>{let e=new Float32Array(24);for(let t=0;t<8;t++){const n=(2*t+.5)/16;e[3*t+0]=n,e[3*t+1]=n,e[3*t+2]=n}return e})()),u=r.createVertexbuffer((()=>{let e=new Float32Array(24);for(let t=0;t<8;t++)e[3*t+0]=0,e[3*t+1]=1,e[3*t+2]=2;return e})()),f=r.createIndexbuffer((()=>{let e=new Uint16Array(126);for(let t=0;t<7;t++)for(let n=0;n<3;n++){const r=(n+1)%3;e[18*t+6*n+0]=3*t+n,e[18*t+6*n+1]=3*t+3+n,e[18*t+6*n+2]=3*t+3+r,e[18*t+6*n+3]=3*t+n,e[18*t+6*n+4]=3*t+3+r,e[18*t+6*n+5]=3*t+r}return e})()),m=r.createVertexbuffer((()=>{let e=new Float32Array(4096);for(let t=0;t<4096;t++)e[t]=(t+.5)/4096;return e})()),c=r.createTexture();r.setTextureFromArray(c,1,1,new Uint8Array([0,0,0,0])),t.add({trailsCompute:{width:16,height:4096,vert:n(2),frag:n(55),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,swapbuffer:!0,float:!0,func:(e,t)=>{r.attribute("p",l,2),r.uniform1f("trails",4096),r.uniform1f("trailLength",8),r.uniform1f("ppp",2),r.uniformTexture("samplerPcompute",e.swapbuffer.texture,0),r.uniform1f("genRate",o("trails-genRate")),r.uniform1f("noiseScale",o("trails-noiseScale")),i.drawArrays(i.TRIANGLE_STRIP,0,4)}},trailsRender:{vert:n(56),frag:n(57),blend:[i.ONE,i.ZERO],drawbuffers:3,func:(e,n)=>{r.attribute("computeU",s,1),r.attribute("triIndex",u,1),r.attributeDivisor("computeV",m,1,1),r.uniform1f("trails",4096),r.uniform1f("trailLength",8),r.uniform1f("ppp",2),r.uniform2fv("resolutionPcompute",[16,4096]),r.uniform1i("isShadow",n.isShadow?1:0),r.uniformTexture("samplerPcompute",t.fb("trailsCompute").texture,0),r.uniformTexture("samplerShadow",n.textureShadow||c,1);let a=r.getExtension("ANGLE_instanced_arrays");i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,f),a.drawElementsInstancedANGLE(i.TRIANGLES,126,i.UNSIGNED_SHORT,0,4096),i.bindBuffer(i.ELEMENT_ARRAY_BUFFER,null)}}})})},function(e,t){e.exports="#define PARTICLE_LIFE_LENGTH 3.0\n\nuniform float trails;\nuniform float trailLength;\nuniform float ppp;\n\nuniform sampler2D samplerPcompute;\nuniform float genRate;\n\n// ------\n\nvec2 vInvert( vec2 _uv ) {\n  return vec2( 0.0, 1.0 ) + vec2( 1.0, -1.0 ) * _uv;\n}\n\n// ------\n\nvec4 random( vec2 _uv ) {\n  return texture2D( samplerRandomDynamic, _uv );\n}\n\n// ------\n\nvoid main() {\n  vec2 uv = gl_FragCoord.xy / resolution;\n  vec2 puv = vec2( ( floor( gl_FragCoord.x / ppp ) * ppp + 0.5 ) / resolution.x, uv.y );\n  float mode = mod( gl_FragCoord.x, ppp );\n  vec2 dpix = vec2( 1.0 ) / resolution;\n\n  float dt = deltaTime;\n\n  // == if it is not head of particles =========================================\n  if ( ppp < gl_FragCoord.x ) {\n    puv.x -= ppp / resolution.x;\n    vec4 pos = texture2D( samplerPcompute, puv );\n    vec4 vel = texture2D( samplerPcompute, puv + dpix * vec2( 1.0, 0.0 ) );\n\n    pos.z += zOffset.y * dt;\n    pos.w = saturate( pos.w - 1.0 / trailLength );\n\n    gl_FragColor = (\n      mode < 1.0 ? pos :\n      vel\n    );\n    return;\n  }\n\n  // == prepare some vars for fuck around head particle ========================\n  vec4 seed = texture2D( samplerRandomDynamic, puv );\n  prng( seed );\n\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dpix * vec2( 1.0, 0.0 ) );\n\n  float timing = mix( 0.0, PARTICLE_LIFE_LENGTH, floor( puv.y * trails ) / trails );\n  timing += lofi( time, PARTICLE_LIFE_LENGTH );\n\n  if ( time - deltaTime + PARTICLE_LIFE_LENGTH < timing ) {\n    timing -= PARTICLE_LIFE_LENGTH;\n  }\n\n  // == initialize particles ===================================================\n  if (\n    time - deltaTime < timing && timing <= time\n  ) {\n    dt = time - timing;\n\n    pos.xyz = 2.0 * vec3( sin( time ), cos( time ), 0.0 );\n    pos.yz = rotate2D( -1.0 ) * pos.yz;\n    pos.xyz *= prng( seed ) < 0.5 ? 1.0 : -1.0;\n    pos.xyz += 0.5 * randomSphere( seed );\n\n    vel.xyz = 1.0 * randomSphere( seed );\n    vel.w = 1.0; // jumping flag\n\n    pos.w = prng( seed ) < genRate ? 1.0 : 0.0; // life\n  } else {\n    vel.w = 0.0; // remove jumping flag\n  }\n\n  // == update particles =======================================================\n  vel.xyz += 40.0 * vec3(\n    noise4d( vec4( 0.4 * pos.xyz, 1.845 + 0.1 * time ) ),\n    noise4d( vec4( 0.4 * pos.xyz, 2.853 + 0.1 * time ) ),\n    noise4d( vec4( 0.4 * pos.xyz, 4.129 + 0.1 * time ) )\n  ) * dt;\n  vel.xyz += 4.0 * dt * smoothstep( 3.0, 1.5, length( pos.xyz ) ) * normalize( pos.xyz );\n  vel.xyz *= exp( -5.0 * dt );\n\n  pos.xyz += vel.xyz * dt;\n  pos.w -= dt / PARTICLE_LIFE_LENGTH;\n\n  gl_FragColor = (\n    mode < 1.0 ? pos :\n    vel\n  );\n}"},function(e,t){e.exports="attribute float computeU;\nattribute float computeV;\nattribute float triIndex;\n\nvarying vec3 vPos;\nvarying vec3 vNor;\nvarying vec3 vCol;\nvarying float vLife;\nvarying float vIsOkayToDraw;\n\nuniform vec2 resolutionPcompute;\nuniform float ppp;\n\nuniform sampler2D samplerPcompute;\n\nvoid main() {\n  vec2 puv = vec2( computeU, computeV );\n  vec2 dppix = vec2( 1.0 ) / resolutionPcompute;\n\n  // == fetch texture ==========================================================\n  vec4 pos = texture2D( samplerPcompute, puv );\n  vec4 vel = texture2D( samplerPcompute, puv + dppix * vec2( 1.0, 0.0 ) );\n  vec4 velp = texture2D( samplerPcompute, puv + dppix * vec2( -ppp + 1.0, 0.0 ) );\n\n  // == assign varying variables ===============================================\n  vLife = pos.w;\n  vPos = pos.xyz;\n\n  vec4 dice = texture2D( samplerRandomStatic, puv.yy * 182.92 );\n  vCol = dice.z < 0.7 ? vec3( 0.8, 0.2 * dice.xy ) : vec3( 0.8 );\n\n  vIsOkayToDraw = ( velp.w < 0.5 && vel.w < 0.5 ) ? 1.0 : 0.0;\n\n  // == compute size and direction =============================================\n  float size = 0.003 + 0.01 * pow( dice.w, 2.0 );\n  vec3 dir = normalize( vel.xyz );\n  vec3 sid = normalize( cross( dir, vec3( 0.0, 1.0, 0.0 ) ) );\n  vec3 top = normalize( cross( sid, dir ) );\n\n  float theta = triIndex / 3.0 * TAU + vLife * 1.0;\n  vec2 tri = vec2( sin( theta ), cos( theta ) );\n  vNor = ( tri.x * sid + tri.y * top );\n  pos.xyz += size * vNor;\n\n  vec4 outPos = matP * matV * vec4( pos.xyz, 1.0 );\n  outPos.x /= resolution.x / resolution.y;\n  gl_Position = outPos;\n}"},function(e,t){e.exports="#extension GL_EXT_draw_buffers : require\n\nvarying vec3 vPos;\nvarying vec3 vNor;\nvarying vec3 vCol;\nvarying float vLife;\nvarying float vIsOkayToDraw;\n\nuniform bool isShadow;\n\nvoid main() {\n  if ( vIsOkayToDraw < 0.5 ) { discard; }\n  if ( vLife <= 0.0 ) { discard; }\n\n  if ( isShadow ) {\n    gl_FragData[ 0 ] = vec4( calcDepthL( vPos - lightPos ), 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  vec3 col = 4.0 * vCol;\n\n  gl_FragData[ 0 ] = vec4( vPos, 1.0 );\n  gl_FragData[ 1 ] = vec4( vNor, 1.0 );\n  gl_FragData[ 2 ] = vec4( col, 1.0 );\n}"},function(e,t,n){"use strict";n.r(t);var r=n(1);n(0);t.default=(e=>{const t=e.glCatPath,a=t.glCat,i=a.gl,o=(e.automaton.auto,a.createVertexbuffer(new Float32Array([-4.5,2.5,0,-3.5,1.5,0,4.5,2.5,0,3.5,1.5,0,4.5,-2.5,0,3.5,-1.5,0,-4.5,-2.5,0,-3.5,-1.5,0,-4.5,2.5,0,-3.5,1.5,0]))),l=a.createVertexbuffer(new Float32Array([0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1])),s=a.createTexture();t.add({ui:{vert:n(59),frag:n(60),blend:[i.ONE,i.ZERO],drawbuffers:3,depthTest:!1,depthWrite:!1,func:(e,t)=>{a.attribute("aPos",o,3),a.attribute("aNor",l,3),a.uniform1i("isShadow",t.isShadow),a.uniform4fv("color",[.2,.3,.4,3]),a.setTextureFromFloatArray(s,2048,1,t.analyserData,i.LUMINANCE),a.uniformTexture("samplerLv",s,0);let n=r.a.mat4Identity();a.uniformMatrix4fv("matM",n),i.drawArrays(i.TRIANGLE_STRIP,0,10)}}})})},function(e,t){e.exports="// == attributes ===============================================================\nattribute vec3 aPos;\nattribute vec3 aNor;\n\n// == varyings =================================================================\nvarying vec3 vPos;\nvarying vec3 vRawPos;\nvarying vec3 vNor;\n\n// == uniforms =================================================================\nuniform bool isShadow;\nuniform mat4 matM;\n\n// == main =====================================================================\nvoid main() {\n  vRawPos = aPos;\n  vec4 pos = matM * vec4( aPos, 1.0 );\n  vPos = pos.xyz;\n\n  vec4 nor = normalize( matM * vec4( aNor, 0.0 ) );\n  vNor = nor.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * pos;\n  } else {\n    outPos = matP * matV * pos;\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n}"},function(e,t){e.exports="// == shit =====================================================================\n#extension GL_EXT_draw_buffers : require\n\n// == varyings =================================================================\nvarying vec3 vPos;\nvarying vec3 vRawPos;\nvarying vec3 vNor;\n\n// == uniforms =================================================================\nuniform bool isShadow;\n\nuniform vec4 color;\n\nuniform sampler2D samplerLv;\n\n// == main =====================================================================\nvoid main() {\n  if ( isShadow ) {\n    gl_FragData[ 0 ] = vec4( calcDepthL( vPos - lightPos ), 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  calcRhythms();\n\n  bool b = 4.47 < abs( vRawPos.x ) || 2.47 < abs( vRawPos.y );\n\n  vec2 circ = vRawPos.xy - vec2( 3.8, -2.1 );\n  circ = rotate2D( zOffset.x ) * circ;\n  b = b || (\n    length( circ ) < 0.25 &&\n    0.2 < length( circ ) &&\n    0.03 < abs( circ.y )\n  ) || length( circ ) < 0.15;\n\n  vec4 rectLv = vec4( 3.5, -1.7, 4.1, 2.4 );\n\n  float lvuv = 0.01 + 0.4 * linearstep( rectLv.y, rectLv.w, lofi( vRawPos.y, 0.1 ) );\n  float lv = 0.1 + 0.9 * linearstep( -90.0, -30.0, texture2D( samplerLv, vec2( lvuv, 0.5 ) ).x );\n  b = b || (\n    inRange( rectLv.y, rectLv.w, vRawPos.y ) &&\n    inRange( mix( rectLv.z, rectLv.x, lv ), rectLv.z, vRawPos.x ) &&\n    abs( mod( vRawPos.y, 0.1 ) - 0.05 ) < 0.03\n  );\n\n  b = b || (\n    abs( abs( vRawPos.x ) - 4.3 ) < 0.1 &&\n    abs( vRawPos.y ) < 2.4 &&\n    mod( vRawPos.x + vRawPos.y + 0.4 * sign( vRawPos.x ) * time, 0.2 ) < 0.15\n  );\n\n  vec2 vRawPosYAbs = vec2( vRawPos.x, abs( vRawPos.y ) );\n\n  b = b || (\n    length( vRawPosYAbs.xy - vec2( 0.0, 2.3 ) ) < 0.05 * smoothstep( 0.2, 0.0, clavTime )\n  );\n\n  b = b || (\n    length( vRawPosYAbs.xy - vec2( -0.2, 2.3 ) ) < 0.05 * smoothstep( 0.2, 0.0, rimshotTime.x )\n  );\n\n  b = b || (\n    length( vRawPosYAbs.xy - vec2( 0.2, 2.3 ) ) < 0.05 * smoothstep( 0.2, 0.0, rimshotTime.y )\n  );\n\n  b = b || (\n    inRange( 2.40, 2.41, vRawPosYAbs.y ) &&\n    abs( vRawPosYAbs.x ) < 0.3 + 0.3 * exp( -0.1 * hihatOpen * hihatTime )\n  );\n\n  if ( !b ) { discard; }\n\n  gl_FragData[ 0 ] = vec4( vPos, 1.0 );\n  gl_FragData[ 1 ] = vec4( vNor, 1.0 );\n  gl_FragData[ 2 ] = vec4( 0.7, 0.9, 1.1, 2.0 );\n}"},function(e,t,n){"use strict";n.r(t);var r=n(1),a=n(0);t.default=(e=>{const t=e.glCatPath,i=t.glCat,o=i.gl,l=e.automaton.auto,s=i.createVertexbuffer(new Float32Array(a.d)),u=i.createVertexbuffer(new Float32Array(a.e)),f=(i.createVertexbuffer(new Float32Array(a.f)),a.b(75,75).map((e,t)=>.4*e-14.8)),m=i.createVertexbuffer(new Float32Array(f));t.add({veryPlane:{vert:n(62),frag:n(63),blend:[o.ONE,o.ZERO],cull:!1,drawbuffers:3,func:(e,t)=>{i.attribute("aPos",s,3),i.attribute("aNor",u,3),i.attributeDivisor("aMatrix",m,2,1),i.uniform1i("isShadow",t.isShadow),i.uniform1f("flipThreshold",l("veryPlane-flipThreshold")),i.uniform4fv("color",[.2,.3,.4,3]);let n=r.a.mat4Apply(r.a.mat4Translate([0,-5,0]),r.a.mat4RotateX(Math.PI/2),r.a.mat4Identity());i.uniformMatrix4fv("matM",n),i.getExtension("ANGLE_instanced_arrays").drawArraysInstancedANGLE(o.TRIANGLE_STRIP,0,4,f.length/2)}}})})},function(e,t){e.exports="// == attributes ===============================================================\nattribute vec3 aPos;\nattribute vec3 aNor;\nattribute vec2 aMatrix;\n\n// == varyings =================================================================\nvarying vec3 vPos;\nvarying vec3 vNor;\nvarying float vFlip;\n\n// == nani =====================================================================\nuniform bool isShadow;\nuniform float flipThreshold;\n\nuniform mat4 matM;\n\n// == main =====================================================================\nvoid main() {\n  vec4 pos = vec4( 0.4 * aPos, 1.0 );\n  float t = mod( time - 1.0 beat, 2.0 beat );\n  float aaaa = random4( 0.179 * aMatrix + 0.188 * ( time - t ) ).x;\n\n  float flip = PI * smoothstep( 1.0, 0.1, exp( -5.0 * t ) );\n  pos.zx = rotate2D(\n    aaaa < flipThreshold * 0.25 ? flip :\n    aaaa < flipThreshold * 0.5 ? -flip :\n    0.0\n  ) * pos.zx;\n  pos.yz = rotate2D(\n    aaaa < flipThreshold * 0.5 ? 0.0 :\n    aaaa < flipThreshold * 0.75 ? flip :\n    aaaa < flipThreshold ? -flip :\n    0.0\n  ) * pos.yz;\n  vFlip = sin( aaaa < flipThreshold ? sin( flip ) : 0.0 );\n\n  pos.x += 2.0 * aMatrix.x;\n  pos.y += mod( 2.0 * aMatrix.y - zOffset.x, 60.0 ) - 20.0;\n  pos = matM * pos;\n\n  float bbbb = random4( 0.179 * aMatrix ).x;\n  pos.y += 1.0 * noise4d( vec4( 0.1 * pos.zx, 0.1 * time, 6.724 ) );\n  vPos = pos.xyz;\n\n  vec4 nor = vec4( aNor, 0.0 );\n  nor = normalize( matM * nor );\n  vNor = nor.xyz;\n\n  vec4 outPos;\n  if ( isShadow ) {\n    outPos = matPL * matVL * pos;\n  } else {\n    outPos = matP * matV * pos;\n    outPos.x /= resolution.x / resolution.y;\n  }\n  gl_Position = outPos;\n}"},function(e,t){e.exports="// == shit =====================================================================\n#extension GL_EXT_draw_buffers : require\n\n// == varyings =================================================================\nvarying vec3 vPos;\nvarying vec3 vNor;\nvarying float vFlip;\n\n// == uniforms =================================================================\nuniform bool isShadow;\n\n// == main =====================================================================\nvoid main() {\n  if ( isShadow ) {\n    gl_FragData[ 0 ] = vec4( calcDepthL( vPos - lightPos ), 0.0, 0.0, 1.0 );\n    return;\n  }\n\n  vec4 col = vec4( mix(\n    vec3( 0.2, 0.3, 0.4 ),\n    vec3( 0.7, 1.8, 1.2 ),\n    sin( vFlip )\n  ), 1.0 );\n\n  gl_FragData[ 0 ] = vec4( vPos, 1.0 );\n  gl_FragData[ 1 ] = vec4( vNor, 1.0 );\n  gl_FragData[ 2 ] = col;\n}"},function(e,t,n){"use strict";n.r(t);var r=n(0);var a=n(3);var i=class{constructor(e){this.gl=e;const t=this.gl;t.enable(t.DEPTH_TEST),t.depthFunc(t.LEQUAL),t.enable(t.BLEND),t.blendFunc(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA),this.__extensions={},this.__currentProgram=null}getExtension(e,t){const n=this.gl;if("object"==typeof e&&e.isArray())return e.every(e=>this.getExtension(e,t));if("string"==typeof e){if(this.__extensions[e])return this.__extensions[e];if(this.__extensions[e]=n.getExtension(e),this.__extensions[e])return this.__extensions[e];if(t)throw new Error('The extension "'+e+'" is not supported');return null}throw new Error("GLCat.getExtension: _name must be string or array")}createProgram(e,t,n){const r=this.gl;let a;a="function"==typeof n?n:e=>{throw new Error(e)};const i=r.createShader(r.VERTEX_SHADER);if(r.shaderSource(i,e),r.compileShader(i),!r.getShaderParameter(i,r.COMPILE_STATUS))return a(r.getShaderInfoLog(i)),r.deleteShader(i),null;const o=r.createShader(r.FRAGMENT_SHADER);if(r.shaderSource(o,t),r.compileShader(o),!r.getShaderParameter(o,r.COMPILE_STATUS))return a(r.getShaderInfoLog(o)),r.deleteShader(i),r.deleteShader(o),null;const l=r.createProgram();return r.attachShader(l,i),r.attachShader(l,o),r.linkProgram(l),r.getProgramParameter(l,r.LINK_STATUS)?{vert:i,frag:o,program:l,locations:{}}:(a(r.getProgramInfoLog(l)),r.deleteShader(i),r.deleteShader(o),r.deleteProgram(l),null)}useProgram(e){this.gl.useProgram(e.program),this.__currentProgram=e}createVertexbuffer(e){const t=this.gl.createBuffer();return e&&this.setVertexbuffer(t,e),t}setVertexbuffer(e,t,n){const r=this.gl,a=n||r.STATIC_DRAW;r.bindBuffer(r.ARRAY_BUFFER,e),r.bufferData(r.ARRAY_BUFFER,t,a),r.bindBuffer(r.ARRAY_BUFFER,null)}createIndexbuffer(e){const t=this.gl.createBuffer();return e&&this.setIndexbuffer(t,e),t}setIndexbuffer(e,t,n){const r=this.gl,a=n||r.STATIC_DRAW;r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,e),r.bufferData(r.ELEMENT_ARRAY_BUFFER,t,a),r.bindBuffer(r.ELEMENT_ARRAY_BUFFER,null)}getAttribLocation(e){const t=this.gl;let n;return this.__currentProgram.locations[e]?n=this.__currentProgram.locations[e]:(n=t.getAttribLocation(this.__currentProgram.program,e),this.__currentProgram.locations[e]=n),n}attribute(e,t,n,r,a,i){const o=this.gl,l=this.getAttribLocation(e);if(-1===l)return;o.bindBuffer(o.ARRAY_BUFFER,t),o.enableVertexAttribArray(l),o.vertexAttribPointer(l,n,r||o.FLOAT,!1,a||0,i||0);const s=this.getExtension("ANGLE_instanced_arrays");s&&s.vertexAttribDivisorANGLE(l,0),o.bindBuffer(o.ARRAY_BUFFER,null)}attributeDivisor(e,t,n,r,a,i,o){const l=this.gl;this.getExtension("ANGLE_instanced_arrays",!0);const s=this.getAttribLocation(e);if(-1===s)return;l.bindBuffer(l.ARRAY_BUFFER,t),l.enableVertexAttribArray(s),l.vertexAttribPointer(s,n,a||l.FLOAT,!1,i||0,o||0);const u=this.getExtension("ANGLE_instanced_arrays");u&&u.vertexAttribDivisorANGLE(s,r),l.bindBuffer(l.ARRAY_BUFFER,null)}getUniformLocation(e){const t=this.gl;let n;return void 0!==this.__currentProgram.locations[e]?n=this.__currentProgram.locations[e]:(n=t.getUniformLocation(this.__currentProgram.program,e),this.__currentProgram.locations[e]=n),n}uniform(e,t,n){const r=this.gl,a=this.getUniformLocation(t);r["uniform"+e](a,n)}uniform1i(e,t){const n=this.gl,r=this.getUniformLocation(e);n.uniform1i(r,t)}uniform1f(e,t){const n=this.gl,r=this.getUniformLocation(e);n.uniform1f(r,t)}uniform2fv(e,t){const n=this.gl,r=this.getUniformLocation(e);n.uniform2fv(r,t)}uniform3fv(e,t){const n=this.gl,r=this.getUniformLocation(e);n.uniform3fv(r,t)}uniform4fv(e,t){const n=this.gl,r=this.getUniformLocation(e);n.uniform4fv(r,t)}uniformMatrix4fv(e,t,n){const r=this.gl,a=this.getUniformLocation(e);r.uniformMatrix4fv(a,n||!1,t)}uniformTexture(e,t,n){const r=this.gl,a=this.getUniformLocation(e);r.activeTexture(r.TEXTURE0+n),r.bindTexture(r.TEXTURE_2D,t),r.uniform1i(a,n)}uniformCubemap(e,t,n){const r=this.gl,a=this.getUniformLocation(e);r.activeTexture(r.TEXTURE0+n),r.bindTexture(r.TEXTURE_CUBE_MAP,t),r.uniform1i(a,n)}createTexture(){const e=this.gl,t=e.createTexture();return e.bindTexture(e.TEXTURE_2D,t),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,e.LINEAR),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE),e.bindTexture(e.TEXTURE_2D,null),t}textureFilter(e,t){const n=this.gl;n.bindTexture(n.TEXTURE_2D,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MAG_FILTER,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,t),n.bindTexture(n.TEXTURE_2D,null)}textureWrap(e,t){const n=this.gl;n.bindTexture(n.TEXTURE_2D,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,t),n.bindTexture(n.TEXTURE_2D,null)}setTexture(e,t){const n=this.gl;n.bindTexture(n.TEXTURE_2D,e),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t),n.bindTexture(n.TEXTURE_2D,null)}setTextureFromArray(e,t,n,r,a){const i=this.gl;i.bindTexture(i.TEXTURE_2D,e),i.texImage2D(i.TEXTURE_2D,0,a||i.RGBA,t,n,0,a||i.RGBA,i.UNSIGNED_BYTE,new Uint8Array(r)),i.bindTexture(i.TEXTURE_2D,null)}setTextureFromFloatArray(e,t,n,r,a){const i=this.gl;this.getExtension("OES_texture_float",!0),i.bindTexture(i.TEXTURE_2D,e),i.texImage2D(i.TEXTURE_2D,0,a||i.RGBA,t,n,0,a||i.RGBA,i.FLOAT,new Float32Array(r)),this.getExtension("OES_texture_float_linear")||this.textureFilter(e,i.NEAREST),i.bindTexture(i.TEXTURE_2D,null)}copyTexture(e,t,n){const r=this.gl;r.bindTexture(r.TEXTURE_2D,e),r.copyTexImage2D(r.TEXTURE_2D,0,r.RGBA,0,0,t,n,0),r.bindTexture(r.TEXTURE_2D,null)}createCubemap(e){const t=this.gl,n=t.createTexture();t.bindTexture(t.TEXTURE_CUBE_MAP,n);for(let n=0;n<6;n++)t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+n,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,e[n]);return t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MIN_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_MAG_FILTER,t.LINEAR),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE),t.texParameteri(t.TEXTURE_CUBE_MAP,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE),t.bindTexture(t.TEXTURE_CUBE_MAP,null),n}createFramebuffer(e,t){const n=this.gl,r={};return r.framebuffer=n.createFramebuffer(),n.bindFramebuffer(n.FRAMEBUFFER,r.framebuffer),r.depth=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,r.depth),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,e,t),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,r.depth),r.texture=this.createTexture(),n.bindTexture(n.TEXTURE_2D,r.texture),n.texImage2D(n.TEXTURE_2D,0,n.RGBA,e,t,0,n.RGBA,n.UNSIGNED_BYTE,null),n.bindTexture(n.TEXTURE_2D,null),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r.texture,0),n.bindFramebuffer(n.FRAMEBUFFER,null),r}resizeFramebuffer(e,t,n){let r=this.gl;r.bindFramebuffer(r.FRAMEBUFFER,e.framebuffer),r.bindRenderbuffer(r.RENDERBUFFER,e.depth),r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_COMPONENT16,t,n),r.bindRenderbuffer(r.RENDERBUFFER,null),r.bindTexture(r.TEXTURE_2D,e.texture),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t,n,0,r.RGBA,r.UNSIGNED_BYTE,null),r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null)}createFloatFramebuffer(e,t){let n=this,r=n.gl;n.getExtension("OES_texture_float",!0);let a={};return a.framebuffer=r.createFramebuffer(),r.bindFramebuffer(r.FRAMEBUFFER,a.framebuffer),a.depth=r.createRenderbuffer(),r.bindRenderbuffer(r.RENDERBUFFER,a.depth),r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_COMPONENT16,e,t),r.framebufferRenderbuffer(r.FRAMEBUFFER,r.DEPTH_ATTACHMENT,r.RENDERBUFFER,a.depth),a.texture=n.createTexture(),r.bindTexture(r.TEXTURE_2D,a.texture),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,e,t,0,r.RGBA,r.FLOAT,null),n.getExtension("OES_texture_float_linear")||n.textureFilter(a.texture,r.NEAREST),r.bindTexture(r.TEXTURE_2D,null),r.framebufferTexture2D(r.FRAMEBUFFER,r.COLOR_ATTACHMENT0,r.TEXTURE_2D,a.texture,0),r.bindFramebuffer(r.FRAMEBUFFER,null),a}resizeFloatFramebuffer(e,t,n){let r=this.gl;r.bindFramebuffer(r.FRAMEBUFFER,e.framebuffer),r.bindRenderbuffer(r.RENDERBUFFER,e.depth),r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_COMPONENT16,t,n),r.bindRenderbuffer(r.RENDERBUFFER,null),r.bindTexture(r.TEXTURE_2D,e.texture),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t,n,0,r.RGBA,r.FLOAT,null),r.bindTexture(r.TEXTURE_2D,null),r.bindFramebuffer(r.FRAMEBUFFER,null)}createDrawBuffers(e,t,n){let r=this,a=r.gl;r.getExtension("OES_texture_float",!0);let i=r.getExtension("WEBGL_draw_buffers",!0);if(i.MAX_DRAW_BUFFERS_WEBGL<n)throw"createDrawBuffers: MAX_DRAW_BUFFERS_WEBGL is "+i.MAX_DRAW_BUFFERS_WEBGL;let o={};o.framebuffer=a.createFramebuffer(),a.bindFramebuffer(a.FRAMEBUFFER,o.framebuffer),o.depth=a.createRenderbuffer(),a.bindRenderbuffer(a.RENDERBUFFER,o.depth),a.renderbufferStorage(a.RENDERBUFFER,a.DEPTH_COMPONENT16,e,t),a.framebufferRenderbuffer(a.FRAMEBUFFER,a.DEPTH_ATTACHMENT,a.RENDERBUFFER,o.depth),o.textures=[];for(let l=0;l<n;l++)o.textures[l]=r.createTexture(),a.bindTexture(a.TEXTURE_2D,o.textures[l]),a.texImage2D(a.TEXTURE_2D,0,a.RGBA,e,t,0,a.RGBA,a.FLOAT,null),r.getExtension("OES_texture_float_linear")||r.textureFilter(o.textures[l],a.NEAREST),a.bindTexture(a.TEXTURE_2D,null),a.framebufferTexture2D(a.FRAMEBUFFER,i.COLOR_ATTACHMENT0_WEBGL+l,a.TEXTURE_2D,o.textures[l],0);let l=a.checkFramebufferStatus(a.FRAMEBUFFER);if(l!==a.FRAMEBUFFER_COMPLETE)throw"createDrawBuffers: gl.checkFramebufferStatus( gl.FRAMEBUFFER ) returns "+l;return a.bindFramebuffer(a.FRAMEBUFFER,null),o}resizeDrawBuffers(e,t,n){let r=this.gl;r.bindFramebuffer(r.FRAMEBUFFER,e.framebuffer),r.bindRenderbuffer(r.RENDERBUFFER,e.depth),r.renderbufferStorage(r.RENDERBUFFER,r.DEPTH_COMPONENT16,t,n),r.bindRenderbuffer(r.RENDERBUFFER,null);for(let a=0;a<e.textures.length;a++)r.bindTexture(r.TEXTURE_2D,e.textures[a]),r.texImage2D(r.TEXTURE_2D,0,r.RGBA,t,n,0,r.RGBA,r.FLOAT,null),r.bindTexture(r.TEXTURE_2D,null);r.bindFramebuffer(r.FRAMEBUFFER,null)}drawBuffers(e){this.gl;let t=this.getExtension("WEBGL_draw_buffers",!0),n=[];if("number"==typeof e)for(let r=0;r<e;r++)n.push(t.COLOR_ATTACHMENT0_WEBGL+r);else n=n.concat(e);t.drawBuffersWEBGL(n)}clear(e,t,n,r,a){let i=this.gl,o=e||0,l=t||0,s=n||0,u="number"==typeof r?r:1,f="number"==typeof a?a:1;i.clearColor(o,l,s,u),i.clearDepth(f),i.clear(i.COLOR_BUFFER_BIT|i.DEPTH_BUFFER_BIT)}};let o=(e,t,n)=>{n.map(n=>{if(void 0===e[n])throw"GLCat-Path: "+n+" is required for "+t})},l=class{constructor(e,t){let n=this;n.glCat=e,n.gl=e.gl,n.paths={},n.commonShader="",n.globalFunc=(()=>{}),n.params=t||{}}add(e){let t=this;for(let n in e){let r=e[n];o(r,"path object",["vert","frag"]),t.paths[n]=r,void 0===r.depthTest&&(r.depthTest=!0),void 0===r.depthWrite&&(r.depthWrite=!0),void 0===r.blend&&(r.blend=[t.gl.SRC_ALPHA,t.gl.ONE_MINUS_SRC_ALPHA]),void 0===r.cull&&(r.cull=!0),r.framebuffer&&(r.drawbuffers?r.framebuffer=t.glCat.createDrawBuffers(r.width,r.height,r.drawbuffers):r.float?r.framebuffer=t.glCat.createFloatFramebuffer(r.width,r.height):r.framebuffer=t.glCat.createFramebuffer(r.width,r.height),r.swapbuffer&&(r.drawbuffers?r.swapbuffer=t.glCat.createDrawBuffers(r.width,r.height,r.drawbuffers):r.float?r.swapbuffer=t.glCat.createFloatFramebuffer(r.width,r.height):r.swapbuffer=t.glCat.createFramebuffer(r.width,r.height)),r.filter&&t.glCat.textureFilter(r.framebuffer.texture,r.filter),r.wrap&&t.glCat.textureWrap(r.framebuffer.texture,r.wrap)),r.program=t.glCat.createProgram(t.commonShader+r.vert,t.commonShader+r.frag)}}render(e,t){let n=this,r=n.paths[e];if(!r)throw"GLCat-Path: The path called "+e+" is not defined!";if(t||(t={}),void 0!==t.enable&&!t.enable&&r.isInitialized)return;r.isInitialized=!0,t.framebuffer=void 0!==t.target?t.target.framebuffer:r.framebuffer?r.framebuffer.framebuffer:null;let a=t.width||r.width,i=t.height||r.height;if(!a||!i)throw"GLCat-Path: width or height is invalid";if(n.gl.viewport(0,0,a,i),n.glCat.useProgram(r.program),r.cull?n.gl.enable(n.gl.CULL_FACE):n.gl.disable(n.gl.CULL_FACE),n.gl.bindFramebuffer(n.gl.FRAMEBUFFER,t.framebuffer),n.params.drawbuffers&&n.glCat.drawBuffers(r.drawbuffers?r.drawbuffers:null===t.framebuffer?[n.gl.BACK]:[n.gl.COLOR_ATTACHMENT0]),n.gl.blendFunc(...r.blend),r.clear&&n.glCat.clear(...r.clear),r.depthTest?n.gl.enable(n.gl.DEPTH_TEST):n.gl.disable(n.gl.DEPTH_TEST),r.depthWrite?n.gl.depthMask(!0):n.gl.depthMask(!1),n.glCat.uniform2fv("resolution",[a,i]),n.globalFunc(r,t),r.func&&r.func(r,t),r.swapbuffer){const e=r.framebuffer;r.framebuffer=r.swapbuffer,r.swapbuffer=e}}renderOutsideOfPipeline(e,t){this.render(e,t)}begin(){}end(){}replaceProgram(e,t,n){const r=this.paths[e];if(!r)throw"GLCat-Path: The path called "+e+" is not defined!";try{const e=r.program,a=this.glCat.createProgram(this.commonShader+t,this.commonShader+n);a&&(r.program=a,this.gl.deleteProgram(e.program),this.gl.deleteShader(e.vert),this.gl.deleteShader(e.frag))}catch(e){console.error(e)}}resize(e,t,n){let r=this,a=r.paths[e];a.width=t,a.height=n,a.framebuffer&&(r.params.drawbuffers&&a.drawbuffers?a.framebuffer=r.glCat.createDrawBuffers(a.width,a.height,a.drawbuffers):a.float?r.glCat.resizeFloatFramebuffer(a.framebuffer,a.width,a.height):r.glCat.resizeFramebuffer(a.framebuffer,a.width,a.height)),"function"==typeof a.onresize&&a.onresize(a,t,n)}setGlobalFunc(e){this.globalFunc=e}fb(e){if(!this.paths[e])throw"glcat-path.fb: path called "+e+" is not defined";if(!this.paths[e].framebuffer)throw"glcat-path.fb: there is no framebuffer for the path "+e;return this.paths[e].framebuffer}};l.nullFb={framebuffer:null};var s=l,u=n(1),f=n(6),m=n.n(f),c=n(4);document.body.style.margin=0,document.body.style.padding=0;const v=document.createElement("canvas");document.body.appendChild(v),v.style.position="fixed",v.style.left="0",v.style.top="0",document.body.style.width=v.style.width="100%",document.body.style.height=v.style.height="100%",v.onclick=(()=>{document.body.requestFullscreen?document.body.requestFullscreen():document.body.webkitRequestFullscreen?document.body.webkitRequestFullscreen():document.body.mozRequestFullscreen&&document.body.mozRequestFullscreen(),C.seek(0)});const p=document.createElement("div");document.body.appendChild(p);const d=document.createElement("divAutomaton");document.body.appendChild(d),d.style.position="fixed",d.style.width="100%",d.style.height="240px",d.style.right=0,d.style.bottom=0;const h=document.createElement("input");h.type="checkbox",h.checked=!0,document.body.appendChild(h);let x=v.width=c.resolution[0],g=v.height=c.resolution[1];const b=v.getContext("webgl");b.lineWidth(1);const _=new i(b);_.getExtension("OES_texture_float",!0),_.getExtension("OES_texture_float_linear",!0),_.getExtension("EXT_frag_depth",!0),_.getExtension("ANGLE_instanced_arrays",!0);const T=new s(_,{el:p,canvas:v,stretch:!0,drawbuffers:!0});T.commonShader=n(9);const E=_.createVertexbuffer(new Float32Array(r.c)),y=(e,t)=>{C.time-C.deltaTime<e&&e<C.time&&t()},w=new class{constructor(e){this.audio=new AudioContext,this.sampleRate=this.audio.sampleRate,this.bufferSize=2048,this.processor=this.audio.createScriptProcessor(this.bufferSize,2,2),this.processor.onaudioprocess=(e=>this.onprocess(e)),this.bufferPoolSize=64,this.bufferPoolIndex=0,this.bufferPool=new Float32Array(4*this.bufferSize*this.bufferPoolSize),this.analyserData=new Float32Array(2048),this.analyser=this.audio.createAnalyser(),this.analyser.fftSize=2048,this.processor.connect(this.audio.destination),this.processor.connect(this.analyser),this.isPlaying=!0,this.currentTime=0,this.currentTimeDate=Date.now();const t=this.glCatPath=e.glCatPath,a=this.glCat=t.glCat,i=this.gl=a.gl,o=a.createVertexbuffer(new Float32Array(r.c)),l=a.createTexture();a.setTextureFromFloatArray(l,8,4,[0,5,10,12,7,19,17,22,0,7,4,14,11,19,16,26,0,2,5,12,7,14,10,22,0,7,4,19,11,26,16,31],i.LUMINANCE),a.textureWrap(l,i.REPEAT),t.add({audio:{width:this.bufferSize,height:this.bufferPoolSize,vert:n(2),frag:n(8),blend:[i.ONE,i.ZERO],clear:[0,0,0,0],framebuffer:!0,float:!0,func:(e,t)=>{a.attribute("p",o,2),a.uniform1f("timeHead",t.time%6),a.uniform1f("patternHead",Math.floor(t.time/6)),a.uniform1f("bufferSize",this.bufferSize),a.uniform1f("sampleRate",this.sampleRate),a.uniformTexture("samplerChord",l,0),i.drawArrays(i.TRIANGLE_STRIP,0,4)}}})}play(){this.isPlaying=!0,this.currentTimeDate=Date.now()}pause(){this.isPlaying=!1}setTime(e){this.currentTime=e,this.currentTimeDate=Date.now(),this.bufferPoolIndex=0}getTime(){let e=this.currentTime-this.bufferSize/this.sampleRate;return this.isPlaying&&(e+=(Date.now()-this.currentTimeDate)/1e3),e}getAnalyserData(){return this.analyser.getFloatFrequencyData(this.analyserData),this.analyserData}onprocess(e){const t=e.outputBuffer.getChannelData(0),n=e.outputBuffer.getChannelData(1);if(this.isPlaying){const e=this.glCatPath,r=this.gl;0===this.bufferPoolIndex&&(e.renderOutsideOfPipeline("audio",{time:this.currentTime}),r.readPixels(0,0,this.bufferSize,this.bufferPoolSize,r.RGBA,r.FLOAT,this.bufferPool));for(let e=0;e<this.bufferSize;e++)t[e]=this.bufferPool[this.bufferPoolIndex+4*e],n[e]=this.bufferPool[this.bufferPoolIndex+4*e+1];this.bufferPoolIndex=(this.bufferPoolIndex+4*this.bufferSize)%(4*this.bufferSize*this.bufferPoolSize),this.currentTime+=this.bufferSize/this.sampleRate,this.currentTimeDate=Date.now()}else for(let e=0;e<this.bufferSize;e++)t[e]=0,n[e]=0}}({glCatPath:T}),R=e=>60*e/160;let A=new a.a(4891789626782);const P=(e,t)=>{_.setTextureFromArray(e,t,t,(()=>{let e=t*t*4,n=new Uint8Array(e);for(let t=0;t<e;t++)n[t]=Math.floor(256*A.gen());return n})())},F=_.createTexture();_.textureWrap(F,b.REPEAT),P(F,2048);const I=_.createTexture();_.textureWrap(I,b.REPEAT);let S=0,D=!0;const C=new m.a({gui:d,data:n(10)}),N=C.auto;C.on("play",()=>{w.play()}),C.on("pause",()=>{w.pause()}),C.on("seek",()=>{w.setTime(C.time),L[0]=0}),C.addFxDefinition("sine",{name:"Sinewave",params:{amp:{name:"Amp",type:"float",default:.1},freq:{name:"Frequency",type:"float",default:5},phase:{name:"Phase",type:"float",default:0,min:0,max:1}},func(e){const t=e.v,n=e.progress*e.params.freq+e.params.phase;return t+e.params.amp*Math.sin(n*Math.PI*2)}}),C.addFxDefinition("repeat",{name:"Repeat",params:{duration:{name:"Duration",type:"float",default:1,min:0}},func(e){const t=e.params.duration;if(0===t)return e.v;const n=e.t0+(e.t-e.t0)%t;return e.getValue(n)}});let L=[0];let O=[0,0,0],z=[0,0,0],M=90,U=[1,.4,5],B=[1,1,1];const G=c.shadowReso;let H=u.a.mat4Perspective(M,.01,20),k=u.a.mat4LookAt(O,z,[0,1,0],0),X=u.a.mat4Perspective(M,.01,20),V=u.a.mat4LookAt(U,z,[0,1,0],0);const q=e=>{M=90*N("camera-fov"),O=[0,0,N("camera-Radius")],O=u.a.rotateVecByQuat(O,u.a.quatAngleAxis(N("camera-rotX",{smooth:10}),[1,0,0])),O=u.a.rotateVecByQuat(O,u.a.quatAngleAxis(N("camera-rotY",{smooth:10}),[0,1,0])),e&&(O=u.a.vecAdd(O,e)),H=u.a.mat4Perspective(M,.01,20),k=u.a.mat4LookAt(O,z,[0,1,0],0),X=u.a.mat4Perspective(M,.01,20),V=u.a.mat4LookAt(U,z,[0,1,0],0)};q();let W=0,Z=0;v.addEventListener("mousemove",e=>{W=e.offsetX,Z=e.offsetY}),T.setGlobalFunc(()=>{_.uniform1i("isInitialFrame",D),_.uniform1f("time",C.time),_.uniform1f("progress",C.progress),_.uniform1f("deltaTime",C.deltaTime),_.uniform1f("totalFrame",S),_.uniform3fv("cameraPos",O),_.uniform3fv("cameraTar",z),_.uniform1f("cameraRoll",0),_.uniform1f("perspFov",M),_.uniform1f("perspNear",.01),_.uniform1f("perspFar",20),_.uniform3fv("lightPos",U),_.uniform3fv("lightCol",B),_.uniformMatrix4fv("matP",H),_.uniformMatrix4fv("matV",k),_.uniformMatrix4fv("matPL",X),_.uniformMatrix4fv("matVL",V),_.uniformTexture("samplerRandomStatic",F,15),_.uniformTexture("samplerRandomDynamic",I,14),_.uniform2fv("mouse",[W,Z]),_.uniform2fv("zOffset",[L[0],N("dzOffset")]),_.uniform3fv("bgColor",[0,0,0])}),T.add({return:{width:x,height:g,vert:n(2),frag:n(11),blend:[b.ONE,b.ZERO],clear:[0,0,0,1],func:(e,t)=>{_.attribute("p",E,2),_.uniformTexture("sampler0",t.input,0),b.drawArrays(b.TRIANGLE_STRIP,0,4)}},inspector:{width:x,height:g,vert:n(2),frag:n(12),blend:[b.ONE,b.ZERO],clear:[0,0,0,1],func:(e,t)=>{_.attribute("p",E,2),_.uniform3fv("circleColor",[1,1,1]),_.uniformTexture("sampler0",t.input,0),b.drawArrays(b.TRIANGLE_STRIP,0,4)}},tone:{width:x,height:g,vert:n(2),frag:n(13),blend:[b.ONE,b.ZERO],clear:[0,0,0,1],func:(e,t)=>{_.attribute("p",E,2),b.drawArrays(b.TRIANGLE_STRIP,0,4)}},target:{width:x,height:g,vert:n(2),frag:n(5),blend:[b.ONE,b.ZERO],clear:[0,0,0,0],framebuffer:!0,float:!0,drawbuffers:3,depthWrite:!1,func:()=>{}},shadow:{width:G,height:G,vert:n(2),frag:n(5),blend:[b.ONE,b.ZERO],clear:[20,0,0,0],framebuffer:!0,float:!0,func:()=>{}}});const j={glCatPath:T,automaton:C,width:x,height:g},Y=n(14).default(j);j.log=Y,n(19).default(j),n(23).default(j),n(26).default(j),n(30).default(j),n(32).default(j),n(34).default(j),n(38).default(j),n(42).default(j),n(46).default(j),n(50).default(j),n(52).default(j),n(54).default(j),n(58).default(j),n(61).default(j);const J=()=>{if(C.update(w.getTime()),h.checked){L[0]+=N("dzOffset")*C.deltaTime,q(),P(I,32),T.begin(),T.render("patternsCompute",{enable:R(16)<C.time}),T.render("particlesCompute",{enable:R(16)<C.time}),T.render("trailsCompute",{enable:R(16)<C.time}),T.render("racerCompute",{enable:R(16)<C.time});for(let e=0;e<3;e++)T.render("logCompute",{enable:R(16)<C.time});T.render("shadow"),T.render("box",{enable:R(16)<C.time,target:T.fb("shadow"),isShadow:!0,width:G,height:G}),T.render("raymarch",{enable:R(16)<C.time,target:T.fb("shadow"),isShadow:!0,width:G,height:G}),T.render("trailsRender",{enable:R(16)<C.time,target:T.fb("shadow"),isShadow:!0,width:G,height:G}),T.render("particlesRender",{enable:R(16)<C.time,target:T.fb("shadow"),isShadow:!0,width:G,height:G}),T.render("veryPlane",{enable:R(16)<C.time,target:T.fb("shadow"),isShadow:!0,width:G,height:G}),T.render("target"),T.render("box",{enable:R(16)<C.time,target:T.fb("target"),width:x,height:g}),T.render("patternsRender",{enable:R(16)<C.time,target:T.fb("target"),width:x,height:g}),T.render("raymarch",{enable:R(16)<C.time,target:T.fb("target"),width:x,height:g}),T.render("circle",{enable:R(16)<C.time,target:T.fb("target"),totalFrame:S,width:x,height:g}),T.render("particlesRender",{enable:R(16)<C.time,target:T.fb("target"),width:x,height:g}),T.render("racerRender",{enable:R(16)<C.time,target:T.fb("target"),width:x,height:g}),T.render("trailsRender",{enable:R(16)<C.time,target:T.fb("target"),width:x,height:g}),T.render("veryPlane",{enable:R(16)<C.time,target:T.fb("target"),width:x,height:g}),T.render("ui",{enable:R(16)<C.time,target:T.fb("target"),width:x,height:g,analyserData:w.getAnalyserData()}),T.render("logRender",{enable:R(16)<C.time,target:T.fb("target"),width:x,height:g}),T.render("render",{enable:R(16)<C.time,inputs:T.fb("target").textures,shadow:T.fb("shadow").texture,width:x,height:g}),T.render("distance",{enable:R(16)<C.time,input:T.fb("target").textures[0],width:x,height:g}),T.render("dof",{enable:R(16)<C.time,dry:T.fb("render").texture,depth:T.fb("distance").texture,width:x,height:g}),T.render("preBloom",{enable:R(16)<C.time,input:T.fb("dof").texture,bias:[-.9,-.9,-.9],factor:[1,1,1]}),T.render("bloom",{enable:R(16)<C.time}),T.render("postBloom",{enable:R(16)<C.time,dry:T.fb("dof").texture}),T.render("post",{enable:R(16)<C.time,input:T.fb("postBloom").texture}),T.render("fxaa",{enable:R(16)<C.time,input:T.fb("post").texture}),T.render("glitch",{enable:R(16)<C.time,input:C.time<R(234)?T.fb("fxaa").texture:C.time<R(234.5)?T.fb("render").texture:C.time<R(235.5)?T.fb("fxaa").texture:C.time<R(236)?T.fb("distance").texture:C.time<R(237.5)?T.fb("fxaa").texture:C.time<R(238)?T.fb("target").textures[0]:C.time<R(238.5)?T.fb("fxaa").texture:C.time<R(239)?T.fb("target").textures[1]:T.fb("fxaa").texture}),T.render("return",{enable:R(16)<C.time,target:s.nullFb,input:T.fb("glitch").texture}),T.render("tone",{enable:C.time<R(16),target:s.nullFb}),S%60==0&&(Y.verb(`Frame: ${S}`),Y.verb(`Time: ${C.time.toFixed(3)} / Beat: ${(e=>e/60*160)(C.time).toFixed(2)}`)),y(R(16),()=>{Y.drop(),Y.info(`Rendering resolution: ${x}x${g}`),Y.info(`Audio buffer size: ${w.bufferSize}`),Y.info("- - - - - - - - - - - - - - -"),Y.info("   Welcome to TDF2018   "),Y.info("You are experiencing ..."),Y.info(""),Y.color([1.3,2.4,.2]),Y.print("FMS_Cat - Until"),Y.color(),Y.print(" (Run time: 2m30s)")}),y(R(48),()=>{Y.info("This entire experience is made of a "),Y.color([1.8,.1,.5]),Y.print("64KB HTML"),Y.info("(Incl. this cool MUSIC !!)")}),y(R(80),()=>{Y.info("Trails activated"),Y.info(" Do you like acid bass? ")}),y(R(144),()=>{Y.info('Entering a section called "ITS_BEGINNING"'),Y.info("Tips: The log is implemented in..."),Y.info("29 Nov 2018 (3 days before the deadline)"),Y.warn(`Now it's ${(new Date).toLocaleTimeString()}... End of party is approaching`)}),y(R(208),()=>{Y.info("Rings activated")}),y(R(224),()=>{Y.info("########################################"),Y.info("## BE PREPARED FOR FURTHER EXPERIENCE ##"),Y.info("########################################"),Y.err("EXCESSIVE_EOM_RESOURCES_REUSE_DETECTED"),Y.err("See for more details:"),Y.err("http://fms-cat-eom.github.io/"),Y.info("Preparing harder kickdrum... OK"),Y.info("Preparing FM powered wobble bass... OK"),Y.info("Initializing FTL translation sequence... OK"),Y.info("Initializing anti-glitch calibrator... Failed"),Y.warn("Global time might be modified in audio shader");for(let e=0;e<999;e++)Y.warn("Random f#%ing number: "+Math.random())}),y(R(240),()=>{Y.drop(),Y.info("FTL translation has successfully done"),Y.info("Particles limit increased: 266,752"),Y.info("IFS fractals activated [Raymarcher]"),Y.warn("Otaku wa sugu IFS fractals")}),y(R(300),()=>{Y.info("I'm so proud of this 909Snare")}),y(R(304),()=>{Y.info("Something weird activated"),Y.info("Greetings, pals :")}),["0x4015","Ctrl-Alt-Test","fsqrt","gam0022","gaz","gyabo","Had2Apps","Jugem-T","notargs","Radium Software","RTX1911","soma_arc","System K","toe on net"].forEach((e,t)=>{y(R(306+2*t),()=>{Y.info(` Hi, ${e} !!`)})}),y(R(336),()=>{Y.info("Also I really want to shoutout to :")}),["NotITG Community (esp. Frums and Taro)","Live Coding & VJ Community","of course, TDF Community"].forEach((e,t)=>{y(R(338+2*t),()=>{Y.info(` I love you, ${e} !!`)})}),y(R(368),()=>{Y.info("I made this prod within 1 weeks, forgive me"),Y.info("== Here is the end of this demo =="),Y.info("==   Thanks all, I love you    ==")}),T.end(),D=!1,S++,requestAnimationFrame(J)}else requestAnimationFrame(J)};J(),window.addEventListener("keydown",e=>{27===e.which&&(h.checked=!1),32===e.which&&(C.isPlaying?C.pause():C.play())})}]);